local url = "https://raw.githubusercontent.com/Footagesus/WindUI/main/dist/main.lua"
local success, err = pcall(function()
    local response = game:HttpGet(url)
    if not response or response == "" then
        error("Failed to fetch WindUI from " .. url)
    end
    local loaded = loadstring(response)
    if not loaded then
        error("Failed to load WindUI script")
    end
    WindUI = loaded()
end)
if not success then
    warn("Error loading WindUI: " .. err)
    return
end

WindUI:AddTheme({
    Name = "Cyan Theme",
    Accent = Color3.fromHex("#18181b"),
    Dialog = Color3.fromHex("#161616"),
    Outline = Color3.fromHex("#06B6D4"),
    Text = Color3.fromHex("#22D3EE"),
    Placeholder = Color3.fromHex("#67E8F9"),
    Background = Color3.fromHex("#0D0D0D"),
    Button = Color3.fromHex("#0891B2"),
    Icon = Color3.fromHex("#22D3EE")
})

WindUI:SetTheme("Cyan Theme")

local Window = WindUI:CreateWindow({
    Title = "XEON DEVELOPMENT",
    Icon = "rocket",
    Folder = "NightsHub",
    Size = UDim2.fromOffset(520, 310),
    Theme = "Cyan Theme",
    SideBarWidth = 200,
    Transparent = true,
    Resizable = true,
})

Tab = Window:Tab({
    Title = "info",
    Icon = "info",
    Locked = false,
})




Tab = Window:Tab({
    Title = "Main",
    Icon = "square",
    Locked = false,
})

Section = Tab:Section({ 
    Title = "Auto Stun",
    Icon = "bird",
    Box = true, 
    FontWeight = Enum.FontWeight.SemiBold,
    TextTransparency = 0,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextSize = 17,
    Opened = true,
})

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local MonsterHitByTorch = ReplicatedStorage.RemoteEvents.MonsterHitByTorch

local hitDeer = false
local hitRam = false
local deer = workspace.Characters:FindFirstChild("Deer")
local ram = workspace.Characters:FindFirstChild("Ram")

Tab:Toggle({
    Title = "Hit Deer with Torch",
    Default = false,
    Callback = function(state)
        hitDeer = state
        if state then
            spawn(function()
                while hitDeer do
                    if deer then
                        MonsterHitByTorch:InvokeServer(deer)
                    end
                    task.wait()
                end
            end)
        end
    end
})

Tab:Toggle({
    Title = "Auto Stun deer (Hold Flashlight)",
    Default = false,
    Callback = function(state)
        hitRam = state
        if state then
            spawn(function()
                while hitRam do
                    if ram then
                        MonsterHitByTorch:InvokeServer(ram)
                    end
                    task.wait()
                end
            end)
        end
    end
})

Section = Tab:Section({
    Title = "God Mode",
    Box = false,
    FontWeight = Enum.FontWeight.SemiBold,
    TextTransparency = 0,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextSize = 17,
    Opened = true,
})

local Players = game:GetService("Players")
local godmodeEnabled = false
local godmodeConnection = nil

local function applyGodmode(humanoid)
    if humanoid and godmodeEnabled then
        humanoid.MaxHealth = 100
        humanoid.Health = 100
        humanoid.BreakJointsOnDeath = false
        if godmodeConnection then
            godmodeConnection:Disconnect()
        end
        godmodeConnection = humanoid.HealthChanged:Connect(function(health)
            if godmodeEnabled and health < 100 then
                humanoid.Health = 100
            end
        end)
    end
end

local function removeGodmode(humanoid)
    if humanoid then
        humanoid.MaxHealth = 100
        humanoid.Health = 100
        humanoid.BreakJointsOnDeath = true
        if godmodeConnection then
            godmodeConnection:Disconnect()
            godmodeConnection = nil
        end
    end
end

Tab:Toggle({
    Title = "God mode (Invincibility)",
    Desc = "Makes you completely invincible to all damage, hunger, and death.",
    Type = "Toggle",
    Default = false,
    Callback = function(state)
        godmodeEnabled = state
        local player = Players.LocalPlayer
        local character = player.Character
        if character then
            local humanoid = character:FindFirstChild("Humanoid")
            if state then
                applyGodmode(humanoid)
            else
                removeGodmode(humanoid)
            end
        end
    end
})

Players.LocalPlayer.CharacterAdded:Connect(function(character)
    if godmodeEnabled then
        local humanoid = character:WaitForChild("Humanoid")
        applyGodmode(humanoid)
    end
end)

task.spawn(function()
    local RunService = game:GetService("RunService")
    while true do
        RunService.RenderStepped:Wait()
        if godmodeEnabled then
            local character = Players.LocalPlayer.Character
            if character then
                local humanoid = character:FindFirstChild("Humanoid")
                if humanoid then
                    if humanoid.Health < 100 then
                        humanoid.Health = 100
                    end
                end
            end
            Players.LocalPlayer:SetAttribute("Hunger", 100)
        end
    end
end)


Section = Tab:Section({ 
    Title = "Hip Height",
    Icon = "diameter",
    Box = true, 
    FontWeight = Enum.FontWeight.SemiBold,
    TextTransparency = 0,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextSize = 17,
    Opened = true,
})

Players = game:GetService("Players")
LocalPlayer = Players.LocalPlayer
Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
Humanoid = Character:WaitForChild("Humanoid")

originalHipHeight = Humanoid.HipHeight
hipHeightSlider = 20
hipHeightEnabled = false

HipHeightSlider = Tab:Slider({
    Title = "Hip Height",
    Step = 1,
    Value = {
        Min = 20,
        Max = 100,
        Default = 20
    },
    Callback = function(value)
        hipHeightSlider = value
        if hipHeightEnabled then
            Humanoid.HipHeight = hipHeightSlider
        end
    end
})

HipHeightToggle = Tab:Toggle({
    Title = "Hip Height",
    Desc = "This Hip height will save you from the hostile Monster/Enemies Use Minimum :20: For It TO work!!",
    Type = "Toggle",
    Default = false,
    Callback = function(state)
        hipHeightEnabled = state
        if hipHeightEnabled then
            Humanoid.HipHeight = hipHeightSlider
        else
            Humanoid.HipHeight = originalHipHeight
        end
    end
})

Section = Tab:Section({ 
    Title = "Chop Tree",
    Icon = "axe",
    Box = true, 
    FontWeight = Enum.FontWeight.SemiBold,
    TextTransparency = 0,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextSize = 17,
    Opened = true,
})

rs = game:GetService("ReplicatedStorage")
plrs = game:GetService("Players")
lp = plrs.LocalPlayer

tdr = rs.RemoteEvents.ToolDamageObject
er = rs.RemoteEvents.EquipItemHandle

hrp = lp.Character and lp.Character:WaitForChild("HumanoidRootPart")
lp.CharacterAdded:Connect(function(c)
    hrp = c:WaitForChild("HumanoidRootPart")
end)

range = 70
chopAuraEnabled = false
active = {}

tdi = {
    ["Old Axe"] = "3_7367831688",
    ["Good Axe"] = "112_7367831688",
    ["Strong Axe"] = "116_7367831688",
    ["Ice Axe"] = "116_7367831688",
    ["Admin Axe"] = "116_7367831688",
    ["Chainsaw"] = "120_7367831688"
}

SelectedTreeTypes = {"Small Tree"}

Slider = Tab:Slider({
    Title = "Range",
    Step = 1,
    Value = { Min = 20, Max = 1000, Default = 70 },
    Callback = function(value)
        range = tonumber(value) or 70
    end
})

TreeDropdown = Tab:Dropdown({
    Title = "Select Trees to Chop",
    Values = {"Snowy Small Tree", "Small Tree", "TreeBig"},
    Value = {"Small Tree"},
    Multi = true,
    AllowNone = true,
    Callback = function(option)
        SelectedTreeTypes = option
    end
})

function gtool()
    inv = lp:FindFirstChild("Inventory")
    if not inv then return nil, nil end
    for toolName, damageID in pairs(tdi) do
        tool = inv:FindFirstChild(toolName)
        if tool then
            return tool, damageID
        end
    end
    return nil, nil
end

function eq(tool)
    if tool then
        er:FireServer("FireAllClients", tool)
    end
end

task.spawn(function()
    while true do
        task.wait(3)
        if chopAuraEnabled then
            tool = gtool()
            if tool then
                eq(tool)
            end
        end
    end
end)

function startloop(tree)
    if not tree:IsA("Model") or not tree:FindFirstChildWhichIsA("BasePart") then return end
    if active[tree] then return end
    active[tree] = true

    task.spawn(function()
        while tree.Parent and active[tree] do
            tool, dmgId = gtool()
            if not tool or not dmgId or not hrp then
                task.wait(0.2)
            else
                pp = tree.PrimaryPart or tree:FindFirstChildWhichIsA("BasePart")
                if not pp then break end

                dist = (hrp.Position - pp.Position).Magnitude
                if dist <= range then
                    tdr:InvokeServer(tree, tool, dmgId, hrp.CFrame)
                end

                cd = tool:GetAttribute("ToolCooldown") or 1
                task.wait(cd)
            end
        end
        active[tree] = nil
    end)
end

AutoChopToggle = Tab:Toggle({
    Title = "Auto Chop Selected Trees",
    Desc = "Chop all trees of selected types in your range",
    Type = "Toggle",
    Default = false,
    Callback = function(state)
        chopAuraEnabled = state
        if state then
            for _, folder in ipairs({workspace.Map.Landmarks, workspace.Map.Foliage}) do
                for _, obj in ipairs(folder:GetChildren()) do
                    if table.find(SelectedTreeTypes, obj.Name) then
                        startloop(obj)
                    end
                end
            end
        else
            for tree, _ in pairs(active) do
                active[tree] = nil
            end
        end
    end
})

for _, folder in ipairs({workspace.Map.Landmarks, workspace.Map.Foliage}) do
    folder.ChildAdded:Connect(function(obj)
        if chopAuraEnabled and table.find(SelectedTreeTypes, obj.Name) then
            startloop(obj)
        end
    end)
end

ReplicatedStorage = game:GetService("ReplicatedStorage")
Workspace = game:GetService("Workspace")
Players = game:GetService("Players")

player = Players.LocalPlayer
autoPlantEnabled = false

function findSapling()
    for _, obj in ipairs(Workspace:GetDescendants()) do
        if obj.Name == "Sapling" and obj:IsA("Model") then
            return obj
        end
    end
    return nil
end

function plantSapling(sapling)
    if not sapling then return end
    position = sapling.PrimaryPart and sapling.PrimaryPart.Position or sapling:GetModelCFrame().p
    ReplicatedStorage.RemoteEvents.RequestPlantItem:InvokeServer(sapling, position)
end

task.spawn(function()
    while true do
        task.wait(1)
        if autoPlantEnabled then
            sapling = findSapling()
            if sapling then
                plantSapling(sapling)
            end
        end
    end
end)

AutoPlantToggle = Tab:Toggle({
    Title = "Auto Plant Sapling",
    Desc = "Auto Plants Saplings",
    Type = "Toggle",
    Default = false,
    Callback = function(state)
        autoPlantEnabled = state
    end
})

Section = Tab:Section({ 
    Title = "Auto Food",
    Icon = "carrot",
    Box = true, 
    FontWeight = Enum.FontWeight.SemiBold,
    TextTransparency = 0,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextSize = 17,
    Opened = true,
})

ReplicatedStorage = game:GetService("ReplicatedStorage")
Players = game:GetService("Players")
Workspace = game:GetService("Workspace")

player = Players.LocalPlayer
Remote = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("RequestConsumeItem")

foodOptions = {
    "Carrot","Berry","Chili","Morsel","Steak","Cooked Morsel","Cooked Steak",
    "Salmon","Clownfish","Mackerel","Cooked Mackerel","Cooked Salmon","Cooked Clownfish",
    "Ribs","Cooked Ribs","Cake","Apple"
}

autoConsumeEnabled = false
selectedFoods = {}
hungerThreshold = 70

FoodDropdown = Tab:Dropdown({
    Title = "Auto Eat Food",
    Values = foodOptions,
    Value = {},
    Multi = true,
    AllowNone = true,
    Callback = function(selected)
        selectedFoods = {}
        for _, food in ipairs(selected) do
            selectedFoods[food] = true
        end
    end
})

HungerSlider = Tab:Slider({
    Title = "Eat Food when Hunger Below",
    Step = 1,
    Value = { Min = 20, Max = 200, Default = 70 },
    Callback = function(value)
        hungerThreshold = tonumber(value) or 70
    end
})

function getNearestFood()
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        return nil
    end
    local nearestFood, shortestDistance = nil, math.huge
    local hrp = player.Character.HumanoidRootPart

    for _, obj in ipairs(Workspace:GetDescendants()) do
        if selectedFoods[obj.Name] and obj:IsA("Model") then
            local root = obj.PrimaryPart or obj:FindFirstChildWhichIsA("BasePart")
            if root then
                local distance = (hrp.Position - root.Position).Magnitude
                if distance < shortestDistance then
                    shortestDistance = distance
                    nearestFood = obj
                end
            end
        end
    end

    return nearestFood
end

task.spawn(function()
    while task.wait(0.5) do
        if autoConsumeEnabled then
            hunger = player:GetAttribute("Hunger") or 0
            if hunger <= hungerThreshold then
                food = getNearestFood()
                if food then
                    Remote:InvokeServer(food)
                end
            end
        end
    end
end)

AutoConsumeToggle = Tab:Toggle({
    Title = "Auto Eat",
    Desc = "Automatically eats food when hunger is low",
    Type = "Toggle",
    Default = false,
    Callback = function(state)
        autoConsumeEnabled = state
    end
}) 

Section = Tab:Section({ 
    Title = "Kill aura (Select)",
    Icon = "hand-fist",
    Box = true, 
    FontWeight = Enum.FontWeight.SemiBold,
    TextTransparency = 0,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextSize = 17,
    Opened = true,
})

local rs = game:GetService("ReplicatedStorage")
local lp = game.Players.LocalPlayer
local ws = workspace
local tdr = rs.RemoteEvents:WaitForChild("ToolDamageObject")

local killAuraEnabled = false
local killRange = 70
local selectedTargets = {}

local toolsDamageIDs = {
    ["Old Axe"] = "3_7367831688",
    ["Good Axe"] = "112_7367831688",
    ["Strong Axe"] = "116_7367831688",
    ["Ice Axe"] = "116_7367831688",
    ["Admin Axe"] = "116_7367831688",
    ["Morningstar"] = "116_7367831688",
    ["Laser Sword"] = "116_7367831688",
    ["Ice Sword"] = "116_7367831688",
    ["Katana"] = "116_7367831688",
    ["Trident"] = "116_7367831688",
    ["Poison Spear"] = "116_7367831688",
    ["Spear"] = "196_8999010016"
}

local npcNames = {
    "Bunny","Wolf","Alpha Wolf","Bear","Cultist","Crossbow Cultist","Juggernaut Cultist",
    "Meteor Crab","Lava Mammoth","FrogKing","Cultist king","Horse","Scorpion","Hellephant","FrogBlue"
}

local function gtool()
    local inv = lp:FindFirstChild("Inventory") or lp:FindFirstChild("Backpack")
    if inv then
        for toolName, dmgID in pairs(toolsDamageIDs) do
            local tool = inv:FindFirstChild(toolName)
            if tool then
                return tool, dmgID
            end
        end
    end
end

Tab:Slider({
    Title = "Range",
    Step = 1,
    Value = { Min = 20, Max = 300, Default = 70 },
    Callback = function(value)
        killRange = tonumber(value) or 70
    end
})

Tab:Dropdown({
    Title = "Enemies",
    Values = npcNames,
    Value = {},
    Multi = true,
    AllowNone = true,
    Callback = function(selected)
        selectedTargets = {}
        for _, name in ipairs(selected) do
            selectedTargets[name] = true
        end
    end
})

Tab:Toggle({
    Title = "Kill Aura",
    Desc = "Auto kill selected enemies in range",
    Type = "Toggle",
    Default = false,
    Callback = function(state)
        killAuraEnabled = state
    end
})

task.spawn(function()
    while task.wait(0.05) do
        if killAuraEnabled and lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
            local tool, dmgID = gtool()
            if tool and dmgID then
                for _, char in ipairs(ws.Characters:GetChildren()) do
                    if selectedTargets[char.Name] and char:IsA("Model") and char:FindFirstChild("HumanoidRootPart") then
                        local dist = (lp.Character.HumanoidRootPart.Position - char.HumanoidRootPart.Position).Magnitude
                        if dist <= killRange then
                            tdr:InvokeServer(char, tool, dmgID, char.HumanoidRootPart.CFrame)
                        end
                    end
                end
            end
        end
    end
end)

Section = Tab:Section({ 
    Title = "Kill aura (Nearby)",
    Icon = "hand-fist",
    Box = true, 
    FontWeight = Enum.FontWeight.SemiBold,
    TextTransparency = 0,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextSize = 17,
    Opened = true,
})

local rs = game:GetService("ReplicatedStorage")
local plrs = game:GetService("Players")
local lp = plrs.LocalPlayer
local ws = workspace

local tdr = rs.RemoteEvents:WaitForChild("ToolDamageObject")

local toolsDamageIDs = {
    ["Old Axe"] = "3_7367831688",
    ["Good Axe"] = "112_7367831688",
    ["Strong Axe"] = "116_7367831688",
    ["Ice Axe"] = "116_7367831688",
    ["Admin Axe"] = "116_7367831688",
    ["Morningstar"] = "116_7367831688",
    ["Laser Sword"] = "116_7367831688",
    ["Ice Sword"] = "116_7367831688",
    ["Katana"] = "116_7367831688",
    ["Trident"] = "116_7367831688",
    ["Poison Spear"] = "116_7367831688",
    ["Spear"] = "196_8999010016"
}

local killAuraEnabled = false
local killRange = 70

local function gtool()
    local inv = lp:FindFirstChild("Backpack") or lp:FindFirstChild("Inventory")
    if inv then
        for toolName, dmgID in pairs(toolsDamageIDs) do
            local tool = inv:FindFirstChild(toolName)
            if tool then
                return tool, dmgID
            end
        end
    end
    return nil, nil
end

local RangeSlider = Tab:Slider({
    Title = "Range",
    Step = 1,
    Value = { Min = 20, Max = 300, Default = 70 },
    Callback = function(value)
        killRange = tonumber(value) or 70
    end
})

local KillAuraToggle = Tab:Toggle({
    Title = "Kill Aura",
    Desc = "Auto Kills All Nearby Enemies in range",
    Type = "Toggle",
    Default = false,
    Callback = function(state)
        killAuraEnabled = state
    end
})

task.spawn(function()
    while task.wait(0.05) do
        if killAuraEnabled and lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
            local tool, dmgID = gtool()
            if tool and dmgID then
                for _, char in ipairs(ws.Characters:GetChildren()) do
                    if char ~= lp.Character and char:IsA("Model") and char:FindFirstChild("HumanoidRootPart") then
                        local hrp = char.HumanoidRootPart
                        local dist = (lp.Character.HumanoidRootPart.Position - hrp.Position).Magnitude
                        if dist <= killRange then
                            tdr:InvokeServer(char, tool, dmgID, hrp.CFrame)
                        end
                    end
                end
            end
        end
    end
end)

Section = Tab:Section({ 
    Title = "Auto Heal",
    Icon = "cross",
    Box = true, 
    FontWeight = Enum.FontWeight.SemiBold,
    TextTransparency = 0,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextSize = 17,
    Opened = true,
})

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local Inventory = player:WaitForChild("Inventory")
local Humanoid = (player.Character or player.CharacterAdded:Wait()):WaitForChild("Humanoid")
local RequestConsumeItem = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("RequestConsumeItem")

local autoBandageEnabled = false
local autoMedKitEnabled = false
local healthThreshold = 50

Tab:Slider({
    Title = "Auto Bandage When Health is Below",
    Step = 1,
    Value = { Min = 1, Max = 100, Default = 50 },
    Callback = function(value)
        healthThreshold = tonumber(value) or 50
    end -- <-- no extra comma here
})

Tab:Toggle({
    Title = "Auto Bandage",
    Desc = "Use Bandage when health is below this value",
    Type = "Toggle",
    Default = false,
    Callback = function(state)
        autoBandageEnabled = state
    end
})

Tab:Toggle({
    Title = "Include MedKit",
    Desc = "Include MedKit to auto heal",
    Type = "Toggle",
    Default = false,
    Callback = function(state)
        autoMedKitEnabled = state
    end
})

local function consumeItem(itemName)
    local item = Inventory:FindFirstChild(itemName)
    if item then
        RequestConsumeItem:InvokeServer(item)
    end
end

RunService.Heartbeat:Connect(function()
    if Humanoid.Health <= healthThreshold then
        if autoBandageEnabled then consumeItem("Bandage") end
        if autoMedKitEnabled then consumeItem("MedKit") end
    end
end)

Section = Tab:Section({ 
    Title = "Others",
    Icon = "gear",
    Box = true, 
    FontWeight = Enum.FontWeight.SemiBold,
    TextTransparency = 0,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextSize = 17,
    Opened = true,
})

local Workspace = game:GetService("Workspace")

local instantOpenEnabled = false

local function makeInstant(prompt)
    prompt.HoldDuration = 0
    prompt.RequiresLineOfSight = false
    prompt.MaxActivationDistance = 10
    prompt.ClickablePrompt = true
end

Tab:Toggle({
    Title = "Instant Open Chests",
    Desc = nil,
    Type = "Toggle",
    Default = false,
    Callback = function(state)
        instantOpenEnabled = state
        if instantOpenEnabled then
            for _, obj in ipairs(Workspace.Items:GetDescendants()) do
                if obj:IsA("ProximityPrompt") then
                    makeInstant(obj)
                end
            end
        end
    end
})

local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local teleportEnabled = false
local nightTriggered = false

local TELEPORT_POSITION = Vector3.new(0, 10, 0)
local NIGHT_START = 18
local NIGHT_END = 6

local function isNight()
    local time = Lighting.ClockTime
    return time >= NIGHT_START or time <= NIGHT_END
end

Tab:Toggle({
    Title = "Teleport to camp at night",
    Desc = nil,
    Type = "Toggle",
    Default = false,
    Callback = function(state)
        teleportEnabled = state
    end
})

RunService.RenderStepped:Connect(function()
    if not teleportEnabled then return end
    local character = player.Character
    if not character then return end
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    if isNight() and not nightTriggered then
        nightTriggered = true
        hrp.CFrame = CFrame.new(TELEPORT_POSITION)
    elseif not isNight() then
        nightTriggered = false
    end
end)

Tab = Window:Tab({
    Title = "Teleports",
    Icon = "map-pin",
    Locked = false,
})

TeleportButton = Tab:Button({
    Title = "Teleport to Camp",
    Locked = false,
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character
        if character and character.PrimaryPart then
            character:SetPrimaryPartCFrame(CFrame.new(0, 10, 0))
        elseif character then
            local hrp = character:FindFirstChild("HumanoidRootPart")
            if hrp then
                hrp.CFrame = CFrame.new(0, 10, 0)
            end
        end
    end
})

TeleportPeltTraderButton = Tab:Button({
    Title = "Teleport To Pelt Trader",
    Locked = false,
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local hrp = character:WaitForChild("HumanoidRootPart")

        local peltTrader = workspace:FindFirstChild("Pelt Trader", true)

        if peltTrader then
            hrp.CFrame = (peltTrader:IsA("Model") and peltTrader:GetPivot() or peltTrader.CFrame) + Vector3.new(0, 5, 0)
        end
    end
})

TeleportFairyButton = Tab:Button({
    Title = "Teleport To Fairy",
    Locked = false,
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local hrp = character:WaitForChild("HumanoidRootPart")

        local fairy = workspace:FindFirstChild("Fairy", true)

        if fairy then
            hrp.CFrame = (fairy:IsA("Model") and fairy:GetPivot() or fairy.CFrame) + Vector3.new(0, 5, 0)
        end
    end
})

TeleportMilitaryBaseButton = Tab:Button({
    Title = "Teleport To Military Base",
    Locked = false,
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local hrp = character:WaitForChild("HumanoidRootPart")

        local militaryBase = workspace:FindFirstChild("Military Base", true)

        if militaryBase then
            hrp.CFrame = (militaryBase:IsA("Model") and militaryBase:GetPivot() or militaryBase.CFrame) + Vector3.new(0, 5, 0)
        end
    end
})

TeleportStrongholdButton = Tab:Button({
    Title = "Teleport To Stronghold",
    Locked = false,
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local hrp = character:WaitForChild("HumanoidRootPart")

        local stronghold = workspace:FindFirstChild("Stronghold", true)

        if stronghold then
            hrp.CFrame = (stronghold:IsA("Model") and stronghold:GetPivot() or stronghold.CFrame) + Vector3.new(0, 5, 0)
        end
    end
})

TeleportCaravanButton = Tab:Button({
    Title = "Teleport To Caravan",
    Locked = false,
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local hrp = character:WaitForChild("HumanoidRootPart")

        local caravan = workspace:FindFirstChild("Caravan", true)

        if caravan then
            hrp.CFrame = (caravan:IsA("Model") and caravan:GetPivot() or caravan.CFrame) + Vector3.new(0, 5, 0)
        end
    end
})

TeleportKingsPalaceButton = Tab:Button({
    Title = "Teleport To Kings Palace",
    Locked = false,
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local hrp = character:WaitForChild("HumanoidRootPart")

        local kingsPalace = workspace:FindFirstChild("Kings Palace", true)

        if kingsPalace then
            hrp.CFrame = (kingsPalace:IsA("Model") and kingsPalace:GetPivot() or kingsPalace.CFrame) + Vector3.new(0, 5, 0)
        end
    end
})



Section = Tab:Section({ 
    Title = "Enemies/Animals",
    Icon = "bird",
    Box = true, 
    FontWeight = Enum.FontWeight.SemiBold,
    TextTransparency = 0,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextSize = 17,
    Opened = true,
})

local selectedEnemy = nil

local EnemyDropdown = Tab:Dropdown({
    Title = "Select Enemy",
    Values = {
        "Bunny", "Wolf", "Alpha Wolf", "Bear", "Cultist", "Crossbow Cultist",
        "Juggernaut Cultist", "Cultist King", "Hellephant", "Mammoth",
        "Meteor Crab", "Scorpion", "Artic Fox", "Polar Bear", "FrogKing",
        "Horse", "Kiwi", "Alien"
    },
    Value = "Bunny",
    Callback = function(option)
        selectedEnemy = option
    end
})

local TeleportButton = Tab:Button({
    Title = "Teleport to Enemy",
    Desc = nil,
    Locked = false,
    Callback = function()
        if not selectedEnemy then return end

        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local hrp = character:WaitForChild("HumanoidRootPart")

        local enemies = {}
        for _, obj in ipairs(workspace:GetDescendants()) do
            if obj.Name == selectedEnemy and obj:IsA("Model") then
                table.insert(enemies, obj)
            end
        end

        if #enemies > 0 then
            local target = enemies[math.random(1, #enemies)]
            local targetPart = target.PrimaryPart or target:FindFirstChildWhichIsA("BasePart")
            if targetPart then
                hrp.CFrame = targetPart.CFrame + Vector3.new(0, 5, 0)
            end
        end
    end
})

Section = Tab:Section({ 
    Title = "Child",
    Icon = "baby",
    Box = true, 
    FontWeight = Enum.FontWeight.SemiBold,
    TextTransparency = 0,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextSize = 17,
    Opened = true,
})

selectedKid = nil

Tab:Dropdown({
    Title = "Select Kid",
    Values = { "DinoKid", "KrakenKid", "SquidKid", "KoalaKid" },
    Value = "DinoKid",
    Callback = function(option)
        selectedKid = option
    end
})

Tab:Button({
    Title = "Teleport to Kid",
    Desc = nil,
    Locked = false,
    Callback = function()
        if not selectedKid then return end

        local lp = game.Players.LocalPlayer
        local char = lp.Character or lp.CharacterAdded:Wait()
        local hrp = char:WaitForChild("HumanoidRootPart")
        local kid = workspace:FindFirstChild(selectedKid, true)

        if kid then
            hrp.CFrame = (kid:IsA("Model") and kid:GetPivot() or kid.CFrame) + Vector3.new(0, 5, 0)
        end
    end
})

Section = Tab:Section({ 
    Title = "Chests",
    Icon = "package",
    Box = true, 
    FontWeight = Enum.FontWeight.SemiBold,
    TextTransparency = 0,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextSize = 17,
    Opened = true,
})

SelectedChest = nil
ChestOptions = {}

function updateChestOptions()
    ChestOptions = {}
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("Model") and (obj.Name:find("Item Chest") or obj.Name:find("Volcanic")) then
            table.insert(ChestOptions, obj.Name)
        end
    end
    SelectedChest = ChestOptions[1]
end

updateChestOptions()

ChestDropdown = Tab:Dropdown({
    Title = "Select Chest",
    Values = ChestOptions,
    Value = SelectedChest,
    Callback = function(option)
        SelectedChest = option
    end
})

TeleportChestButton = Tab:Button({
    Title = "Teleport to Selected Chest",
    Callback = function()
        if not SelectedChest then return end
        local plr = game.Players.LocalPlayer
        local char = plr.Character or plr.CharacterAdded:Wait()
        local hrp = char:WaitForChild("HumanoidRootPart")

        local matches = {}
        for _, obj in ipairs(workspace:GetDescendants()) do
            if obj:IsA("Model") and obj.Name == SelectedChest then
                table.insert(matches, obj)
            end
        end

        if #matches > 0 then
            hrp.CFrame = matches[math.random(1,#matches)]:GetPivot() + Vector3.new(0,5,0)
        end
    end
})

RefreshChestsButton = Tab:Button({
    Title = "Refresh Chest List",
    Callback = function()
        updateChestOptions()
        ChestDropdown:UpdateValues(ChestOptions)
    end
})

TeleportRandomChestButton = Tab:Button({
    Title = "Teleport to Random Chest",
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local hrp = character:WaitForChild("HumanoidRootPart")

        local matches = {}
        for _, obj in ipairs(workspace:GetDescendants()) do
            if obj:IsA("Model") and (obj.Name:find("Item Chest") or obj.Name:find("Volcanic")) then
                table.insert(matches, obj)
            end
        end

        if #matches > 0 then
            local target = matches[math.random(1, #matches)]
            hrp.CFrame = target:GetPivot() + Vector3.new(0, 5, 0)
        end
    end
})

Section = Tab:Section({ 
    Title = "Fuel",
    Icon = "fuel",
    Box = true, 
    FontWeight = Enum.FontWeight.SemiBold,
    TextTransparency = 0,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextSize = 17,
    Opened = true,
})

SelectedObject = nil

DropdownObjects = {
    "Sapling","Log","Coal","Chair","Fuel Canister","Oil Barrel","Biofuel",
    "Cultist Corpse","Crossbow Cultist Corpse","Juggernaut Cultist Corpse",
    "Wolf Corpse","Alpha Wolf Corpse","Bear Corpse"
}

ObjectDropdown = Tab:Dropdown({
    Title = "Select Object",
    Values = DropdownObjects,
    Value = DropdownObjects[1],
    Callback = function(option)
        SelectedObject = option
    end
})

TeleportButton = Tab:Button({
    Title = "Teleport to Object",
    Callback = function()
        if not SelectedObject then return end

        local plr = game.Players.LocalPlayer
        local char = plr.Character or plr.CharacterAdded:Wait()
        local hrp = char:WaitForChild("HumanoidRootPart")

        local matches = {}
        for _, obj in ipairs(workspace:GetDescendants()) do
            if obj.Name == SelectedObject then
                table.insert(matches, obj)
            end
        end

        if #matches > 0 then
            local target = matches[math.random(1, #matches)]
            hrp.CFrame = (target:IsA("Model") and target:GetPivot() or target.CFrame) + Vector3.new(0, 5, 0)
        end
    end
})

Section = Tab:Section({ 
    Title = "Scrap",
    Icon = "cog",
    Box = true, 
    FontWeight = Enum.FontWeight.SemiBold,
    TextTransparency = 0,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextSize = 17,
    Opened = true,
})

SelectedItem = nil

DropdownItems = {
    "Bolt","Sheet Metal","Broken Fan","Old Radio","Metal Chair","Old Microwave",
    "Tyre","Old Car Engine","Washing Machine","Cultist Prototype","Cultist Experiment",
    "Cultist Gem","Forest Gem"
}

ItemDropdown = Tab:Dropdown({
    Title = "Select Scrap",
    Values = DropdownItems,
    Value = DropdownItems[1],
    Callback = function(option)
        SelectedItem = option
    end
})

TeleportButtonItem = Tab:Button({
    Title = "Teleport to Scrap",
    Callback = function()
        if not SelectedItem then return end

        local plr = game.Players.LocalPlayer
        local char = plr.Character or plr.CharacterAdded:Wait()
        local hrp = char:WaitForChild("HumanoidRootPart")

        local matches = {}
        for _, obj in ipairs(workspace:GetDescendants()) do
            if obj.Name == SelectedItem then
                table.insert(matches, obj)
            end
        end

        if #matches > 0 then
            local target = matches[math.random(1, #matches)]
            hrp.CFrame = (target:IsA("Model") and target:GetPivot() or target.CFrame) + Vector3.new(0, 5, 0)
        end
    end
})

Tab = Window:Tab({
    Title = "Automatic",
    Icon = "telescope",
    Locked = false,
})

Section = Tab:Section({ 
    Title = "Auto Fuel (TweenSource)",
    Icon = "fuel",
    Box = true, 
    FontWeight = Enum.FontWeight.SemiBold,
    TextTransparency = 0,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextSize = 17,
    Opened = true,
})

Players = game:GetService("Players")
ReplicatedStorage = game:GetService("ReplicatedStorage")
TweenService = game:GetService("TweenService")
ws = workspace

lp = Players.LocalPlayer
character = lp.Character or lp.CharacterAdded:Wait()
hrp = character:WaitForChild("HumanoidRootPart")
camera = ws.CurrentCamera

startDrag = ReplicatedStorage.RemoteEvents:WaitForChild("RequestStartDraggingItem")
stopDrag = ReplicatedStorage.RemoteEvents:WaitForChild("StopDraggingItem")

selectedItems = {}
autoBringEnabled = false
bringPos = CFrame.new(0, 10, 0)
camPos = CFrame.new(2, 9, 2)
bringDistanceThreshold = 15

ItemDropdown = Tab:Dropdown({
    Title = "Select Fuel",
    Values = { "Log","Chair","Coal","Fuel Canister","Oil Barrel","Wolf Corpse","Alpha Wolf Corpse","Bear Corpse","Cultist Corpse" },
    Value = {},
    Multi = true,
    AllowNone = true,
    Callback = function(selected)
        selectedItems = {}
        for i = 1,#selected do
            selectedItems[selected[i]] = true
        end
    end
})

ToggleBring = Tab:Toggle({
    Title = "Auto Fuel Campfire (BETA)",
    Desc = nil,
    Type = "Toggle",
    Default = false,
    Callback = function(state)
        autoBringEnabled = state
    end
})

task.spawn(function()
    while true do
        if autoBringEnabled then
            camera.CFrame = camPos
            pool = {}

            for i = 1,#ws.Items:GetChildren() do
                item = ws.Items:GetChildren()[i]
                if item:IsA("Model") and selectedItems[item.Name] then
                    pivot = item:GetPivot()
                    if (pivot.Position - bringPos.Position).Magnitude > bringDistanceThreshold then
                        table.insert(pool, item)
                    end
                end
            end

            if #pool > 0 then
                tweenCount = math.max(1, math.floor(#pool * 0.5))
                for i = 1,#pool do
                    if not autoBringEnabled then break end
                    bringItem = pool[i]

                    if i <= tweenCount then
                        pivot = bringItem:GetPivot()
                        tween = TweenService:Create(hrp, TweenInfo.new(0.05, Enum.EasingStyle.Linear), {CFrame = pivot * CFrame.new(0,3,0)})
                        tween:Play()
                        tween.Completed:Wait()
                    end

                    startDrag:FireServer(bringItem)
                    bringItem:PivotTo(bringPos)
                    stopDrag:FireServer(bringItem)
                end
            end
        else
            task.wait(0.05)
        end
        task.wait()
    end
end)

Section = Tab:Section({ 
    Title = "Auto fuel (Insta)",
    Icon = "fuel",
    Box = true, 
    FontWeight = Enum.FontWeight.SemiBold,
    TextTransparency = 0,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextSize = 17,
    Opened = true,
})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ws = workspace

local lp = Players.LocalPlayer
local character = lp.Character or lp.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

local startDrag = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("RequestStartDraggingItem")
local stopDrag = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("StopDraggingItem")

local selectedItems = {}
local autoBringEnabled = false
local bringPos = CFrame.new(0, 10, 0)

local ItemDropdown = Tab:Dropdown({
Title = "Select Fuel",
Values = { "Log","Chair","Coal","Fuel Canister","Oil Barrel","Wolf Corpse","Alpha Wolf Corpse","Bear Corpse","Cultist Corpse" },
Value = {},
Multi = true,
AllowNone = true,
Callback = function(selected)
selectedItems = {}
for _, name in ipairs(selected) do
selectedItems[name] = true
end
end
})

local ToggleBring = Tab:Toggle({
Title = "Auto Fuel Campfire 2",
Desc = nil,
Type = "Toggle",
Default = false,
Callback = function(state)
autoBringEnabled = state
end
})

task.spawn(function()
while true do
if autoBringEnabled then
for _, item in ipairs(ws.Items:GetChildren()) do
if item:IsA("Model") and selectedItems[item.Name] then
if (item:GetPivot().Position - bringPos.Position).Magnitude > 1 then
startDrag:FireServer(item)
item:PivotTo(bringPos)
stopDrag:FireServer(item)
end
end
end
end
task.wait(0.01)
end
end)

Section = Tab:Section({ 
    Title = "Auto Shred Scrap (Uses Tween for godly advantage)",
    Icon = "cog",
    Box = true, 
    FontWeight = Enum.FontWeight.SemiBold,
    TextTransparency = 0,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextSize = 17,
    Opened = true,
})

Players = game:GetService("Players")
ReplicatedStorage = game:GetService("ReplicatedStorage")
TweenService = game:GetService("TweenService")
ws = workspace

lp = Players.LocalPlayer
character = lp.Character or lp.CharacterAdded:Wait()
hrp = character:WaitForChild("HumanoidRootPart")

startDrag = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("RequestStartDraggingItem")
stopDrag = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("StopDraggingItem")

selectedItems = {}
autoBringEnabled = false
bringPos = CFrame.new(21, 14, -6)

ItemDropdown = Tab:Dropdown({
    Title = "Select Items",
    Values = {
        "Bolt","Sheet Metal","Broken Fan","Old Radio","Broken Microwave",
        "Tyre","Metal Chair","Old Car Engine","Washing Machine",
        "Cultist Experiment","Cultist Prototype"
    },
    Value = {},
    Multi = true,
    AllowNone = true,
    Callback = function(selected)
        selectedItems = {}
        for i = 1, #selected do
            selectedItems[selected[i]] = true
        end
    end
})

ToggleBring = Tab:Toggle({
    Title = "Auto Shred Scrap",
    Desc = nil,
    Type = "Toggle",
    Default = false,
    Callback = function(state)
        autoBringEnabled = state
    end
})

function tweenToPosition(targetCFrame)
    tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut)
    goal = {CFrame = targetCFrame}
    tween = TweenService:Create(hrp, tweenInfo, goal)
    tween:Play()
    tween.Completed:Wait()
end

task.spawn(function()
    while true do
        if autoBringEnabled then
            items = ws.Items:GetChildren()
            for i = 1, #items do
                item = items[i]
                if item:IsA("Model") and selectedItems[item.Name] then
                    pivot = item:GetPivot()
                    if (pivot.Position - bringPos.Position).Magnitude > 15 then
                        tweenToPosition(pivot * CFrame.new(0, 3, 0))
                        startDrag:FireServer(item)
                        item:PivotTo(CFrame.new(bringPos.Position))
                        stopDrag:FireServer(item)
                        task.wait(0.01)
                    end
                end
            end
        end
        task.wait(0.01)
    end
end)

Section = Tab:Section({ 
    Title = "Auto Shred Scrap (Insta)",
    Icon = "cog",
    Box = true, 
    FontWeight = Enum.FontWeight.SemiBold,
    TextTransparency = 0,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextSize = 17,
    Opened = true,
})

Players = game:GetService("Players")
ReplicatedStorage = game:GetService("ReplicatedStorage")
ws = workspace

lp = Players.LocalPlayer
character = lp.Character or lp.CharacterAdded:Wait()
hrp = character:WaitForChild("HumanoidRootPart")

startDrag = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("RequestStartDraggingItem")
stopDrag = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("StopDraggingItem")

selectedItems = {}
autoBringEnabled = false
bringPos = CFrame.new(0, 10, 0)

ItemDropdown = Tab:Dropdown({
    Title = "Select Items",
    Values = {
        "Bolt","Sheet Metal","Broken Fan","Old Radio","Broken Microwave",
        "Tyre","Metal Chair","Old Car Engine","Washing Machine",
        "Cultist Experiment","Cultist Prototype","Forest Gem"
    },
    Value = {},
    Multi = true,
    AllowNone = true,
    Callback = function(selected)
        selectedItems = {}
        for i = 1, #selected do
            selectedItems[selected[i]] = true
        end
    end
})

ToggleBring = Tab:Toggle({
    Title = "Auto Shred Scrap",
    Desc = nil,
    Type = "Toggle",
    Default = false,
    Callback = function(state)
        autoBringEnabled = state
    end
})

task.spawn(function()
    while true do
        if autoBringEnabled then
            items = ws.Items:GetChildren()
            for i = 1, #items do
                item = items[i]
                if item:IsA("Model") and selectedItems[item.Name] then
                    startDrag:FireServer(item)
                    item:PivotTo(bringPos)
                    stopDrag:FireServer(item)
                end
            end
        end
        task.wait(0.01)
    end
end)

Section = Tab:Section({ 
    Title = "Flowers",
    Icon = "flower-2",
    Box = true, 
    FontWeight = Enum.FontWeight.SemiBold,
    TextTransparency = 0,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextSize = 17,
    Opened = true,
})

rs = game:GetService("ReplicatedStorage")
wp = game:GetService("Workspace")

r = rs.RemoteEvents:WaitForChild("RequestPickFlower")
lm = wp.Map.Landmarks

autoPickEnabled = false

TogglePickFlowers = Tab:Toggle({
    Title = "Auto Pick Flowers",
    Desc = nil,
    Type = "Toggle",
    Default = false,
    Callback = function(state)
        autoPickEnabled = state
    end
})

function pickFlower(flower)
    pcall(function()
        r:InvokeServer(flower)
    end)
end

function checkFlowers()
    if not autoPickEnabled then return end
    flowers = lm:GetDescendants()
    for i = 1,#flowers do
        f = flowers[i]
        if f.Name == "Flower" then
            pickFlower(f)
        end
    end
end

lm.DescendantAdded:Connect(function(d)
    if d.Name == "Flower" and autoPickEnabled then
        pickFlower(d)
    end
end)

task.spawn(function()
    while true do
        task.wait(0.3)
        checkFlowers()
    end
end)

checkFlowers()

Section = Tab:Section({ 
    Title = "Auto Collect Coin",
    Icon = "coins",
    Box = true, 
    FontWeight = Enum.FontWeight.SemiBold,
    TextTransparency = 0,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextSize = 17,
    Opened = true,
})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

local hrp
if Players.LocalPlayer.Character then
    hrp = Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
end
Players.LocalPlayer.CharacterAdded:Connect(function(c)
    hrp = c:WaitForChild("HumanoidRootPart")
end)

local RequestCollectCoints = ReplicatedStorage.RemoteEvents:WaitForChild("RequestCollectCoints")

_G.autoCollectCoins = false

Tab:Toggle({
    Title = "Auto Collect Coins",
    Type = "Toggle",
    Default = false,
    Callback = function(state)
        _G.autoCollectCoins = state
    end
})

task.spawn(function()
    while task.wait(0.2) do
        if _G.autoCollectCoins then
            for _, obj in ipairs(Workspace:GetDescendants()) do
                if obj:IsA("Model") and obj.Name:find("Coin Stack") then
                    pcall(function()
                        RequestCollectCoints:InvokeServer(obj)
                    end)
                end
            end
        end
    end
end)

Section = Tab:Section({ 
    Title = "Seed Box",
    Icon = "bean",
    Box = true, 
    FontWeight = Enum.FontWeight.SemiBold,
    TextTransparency = 0,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextSize = 17,
    Opened = true,
})

Tab:Toggle({
    Title = "Auto Open Seed Box",
    Desc = nil,
    Icon = "leaf",
    Type = "Toggle",
    Default = false,
    Callback = function(state)
        getgenv().autoOpenSeeds = state

        if state then  
            getgenv().autoOpenSeedsThread = task.spawn(function()  
                local ReplicatedStorage = game:GetService("ReplicatedStorage")  
                local Workspace = game:GetService("Workspace")  
                local Players = game:GetService("Players")  

                local lp = Players.LocalPlayer  
                local hrp = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")  

                lp.CharacterAdded:Connect(function(c)  
                    hrp = c:WaitForChild("HumanoidRootPart")  
                end)  

                local RequestPlantSeeds = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("RequestPlantSeeds")  

                while getgenv().autoOpenSeeds and task.wait(0.5) do  
                    if hrp then  
                        for _, obj in ipairs(Workspace:GetDescendants()) do  
                            if obj:IsA("Model") and obj.Name:find("Seed Box") then  
                                RequestPlantSeeds:InvokeServer(obj)  
                            end  
                        end  
                    end  
                end  
            end)  
        else  
            if getgenv().autoOpenSeedsThread then  
                task.cancel(getgenv().autoOpenSeedsThread)  
                getgenv().autoOpenSeedsThread = nil  
            end  
        end  
    end
})

Section = Tab:Section({ 
    Title = "Crockpot",
    Icon = "cooking-pot",
    Box = true, 
    FontWeight = Enum.FontWeight.SemiBold,
    TextTransparency = 0,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextSize = 17,
    Opened = true,
})

Players = game:GetService("Players")
ReplicatedStorage = game:GetService("ReplicatedStorage")
WorkspaceItems = workspace:WaitForChild("Items")
StartDrag = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("RequestStartDraggingItem")
StopDrag = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("StopDraggingItem")
lp = Players.LocalPlayer
hrp = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")

if not hrp then return end

selectedItems = {"Carrot"}
toggleActive = false

Dropdown = Tab:Dropdown({
    Title = "Select Items",
    Values = {"Carrot", "Apple", "Morsel", "Cooked Morsel", "Steak", "Cooked Steak"},
    Value = {"Carrot"},
    Multi = true,
    AllowNone = true,
    Callback = function(option)
        selectedItems = option
    end
})

Toggle = Tab:Toggle({
    Title = "Auto Crockpot",
    Desc = "Auto Make Stews Basically",
    Icon = "bird",
    Type = "Toggle",
    Default = false,
    Callback = function(state)
        toggleActive = state

        if state then
            task.spawn(function()
                while toggleActive do
                    filteredItems = {}
                    children = WorkspaceItems:GetChildren()
                    for i = 1, #children do
                        item = children[i]
                        if table.find(selectedItems, item.Name) then
                            table.insert(filteredItems, item)
                        end
                    end

                    for i = 1, math.min(3, #filteredItems) do
                        idx = math.random(1, #filteredItems)
                        item = filteredItems[idx]
                        table.remove(filteredItems, idx)

                        part = item:IsA("Model") and (item.PrimaryPart or item:FindFirstChildWhichIsA("BasePart") or item:FindFirstChild("Handle")) or item
                        if part then
                            if item:IsA("Model") and not item.PrimaryPart then
                                item.PrimaryPart = part
                            end

                            crockPot = workspace:FindFirstChild("Crock Pot")
                            if crockPot and crockPot.PrimaryPart then
                                StartDrag:FireServer(item)
                                item:SetPrimaryPartCFrame(crockPot.PrimaryPart.CFrame)
                                StopDrag:FireServer(item)
                            end
                        end
                    end

                    task.wait(10)
                end
            end)
        end
    end
})

Section = Tab:Section({ 
    Title = "Meat",
    Icon = "ham",
    Box = true, 
    FontWeight = Enum.FontWeight.SemiBold,
    TextTransparency = 0,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextSize = 17,
    Opened = true,
})

Players = game:GetService("Players")
ReplicatedStorage = game:GetService("ReplicatedStorage")
WorkspaceItems = workspace:WaitForChild("Items")
StartDrag = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("RequestStartDraggingItem")
StopDrag = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("StopDraggingItem")
lp = Players.LocalPlayer
hrp = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")

if not hrp then return end

selectedItems2 = {"Morsel"}

Dropdown2 = Tab:Dropdown({
    Title = "Select Items to Bring Once",
    Values = {"Morsel", "Steak", "Ribs"},
    Value = {"Morsel"},
    Multi = true,
    AllowNone = true,
    Callback = function(option)
        selectedItems2 = option
    end
})

Toggle2 = Tab:Toggle({
    Title = "Auto Cook Meat",
    Desc = "Auto Cooks Food basically yk meat",
    Icon = "bird",
    Type = "Toggle",
    Default = false,
    Callback = function(state)
        if state then
            filteredItems = {}
            children = WorkspaceItems:GetChildren()
            for i = 1, #children do
                item = children[i]
                if table.find(selectedItems2, item.Name) then
                    table.insert(filteredItems, item)
                end
            end

            for i = 1, #filteredItems do
                item = filteredItems[i]
                part = item:IsA("Model") and (item.PrimaryPart or item:FindFirstChildWhichIsA("BasePart") or item:FindFirstChild("Handle")) or item
                if part then
                    if item:IsA("Model") and not item.PrimaryPart then
                        item.PrimaryPart = part
                    end

                    targetPos = CFrame.new(0,10,0)
                    StartDrag:FireServer(item)
                    item:SetPrimaryPartCFrame(targetPos)
                    StopDrag:FireServer(item)
                end
            end
        end
    end
})

Section = Tab:Section({ 
    Title = "Auto Days",
    Icon = "cog",
    Box = true, 
    FontWeight = Enum.FontWeight.SemiBold,
    TextTransparency = 0,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextSize = 17,
    Opened = true,
})

Players = game:GetService("Players")
Workspace = game:GetService("Workspace")

lp = Players.LocalPlayer
character = lp.Character or lp.CharacterAdded:Wait()
hrp = character:WaitForChild("HumanoidRootPart")

baseplate = nil

BaseToggle = Tab:Toggle({
    Title = "Safe",
    Type = "Toggle",
    Default = false,
    Callback = function(state)
        if state then
            if baseplate then
                baseplate:Destroy()
            end
            baseplate = Instance.new("Part")
            baseplate.Size = Vector3.new(50,50,50)
            baseplate.Anchored = true
            baseplate.Position = Vector3.new(0,6009,0)
            baseplate.Material = Enum.Material.Grass
            baseplate.Color = Color3.fromRGB(0,100,0)
            baseplate.Name = "SafeZoneBaseplate"
            baseplate.Parent = Workspace
            hrp.CFrame = CFrame.new(baseplate.Position + Vector3.new(0,5,0))
        else
            if baseplate then
                baseplate:Destroy()
                baseplate = nil
            end
            hrp.CFrame = CFrame.new(0,10,0)
        end
    end
})

Section = Tab:Section({ 
    Title = "Circle Planting",
    Icon = "sprout",
    Box = true, 
    FontWeight = Enum.FontWeight.SemiBold,
    TextTransparency = 0,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextSize = 17,
    Opened = true,
})

getgenv().plantRadius = getgenv().plantRadius or 70
getgenv().plantCenterPos = Vector3.new(-2, 4, 0)
getgenv().lastCircleAngle = getgenv().lastCircleAngle or 0
getgenv().saplingGap = 2

Tab:Slider({
    Title = "Circle Planting Radius",
    Step = 1,
    Value = { Min = 70, Max = 300, Default = getgenv().plantRadius },
    Callback = function(value)
        value = math.max(70, value)
        getgenv().plantRadius = value
        getgenv().lastCircleAngle = 0
        print(" Circle radius updated to:", getgenv().plantRadius)
    end
})

Tab:Button({
    Title = "Plant Saplings in a Circle",
    Desc = nil,
    Locked = false,
    Callback = function()
        task.spawn(function()
            local Players = game:GetService("Players")
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local Workspace = game:GetService("Workspace")
            local StarterGui = game:GetService("StarterGui")
            local workspaceItems = Workspace:WaitForChild("Items")

            local startDrag = ReplicatedStorage.RemoteEvents:WaitForChild("RequestStartDraggingItem")
            local stopDrag = ReplicatedStorage.RemoteEvents:WaitForChild("StopDraggingItem")
            local requestPlant = ReplicatedStorage.RemoteEvents:WaitForChild("RequestPlantItem")

            local radius = getgenv().plantRadius
            local centerPos = getgenv().plantCenterPos
            local spacing = getgenv().saplingGap

            local saplings = {}
            for _, item in ipairs(workspaceItems:GetChildren()) do
                if item.Name == "Sapling" and (item:IsA("Model") or item:IsA("BasePart")) then
                    table.insert(saplings, item)
                end
            end

            if #saplings == 0 then
                StarterGui:SetCore("SendNotification", {
                    Title = "SpamX Notification",
                    Text = "No saplings found!",
                    Duration = 4
                })
                return
            end

            local lp = Players.LocalPlayer
            local hrp = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
            if not hrp then
                StarterGui:SetCore("SendNotification", {
                    Title = "SpamX Notification",
                    Text = "Player character not found!",
                    Duration = 4
                })
                return
            end

            local reservedPositions = {}
            for _, item in ipairs(workspaceItems:GetChildren()) do
                if item.Name == "Sapling" and item:IsA("Model") and item.PrimaryPart then
                    table.insert(reservedPositions, item.PrimaryPart.Position)
                end
            end

            local angle = getgenv().lastCircleAngle
            for i, sapling in ipairs(saplings) do
                local angleStep = 2 * math.asin(spacing / (2 * radius))
                local x = centerPos.X + math.cos(angle) * radius
                local z = centerPos.Z + math.sin(angle) * radius
                local y = centerPos.Y
                local pos = Vector3.new(x, y, z)

                local skip = false
                for _, p in ipairs(reservedPositions) do
                    if (pos - p).Magnitude < spacing then
                        skip = true
                        break
                    end
                end
                if skip then
                    angle = angle + angleStep
                    continue
                end

                local part = sapling:IsA("Model") and (sapling.PrimaryPart or sapling:FindFirstChildWhichIsA("BasePart") or sapling:FindFirstChild("Handle")) or sapling
                if part then
                    if sapling:IsA("Model") and not sapling.PrimaryPart then
                        pcall(function() sapling.PrimaryPart = part end)
                    end

                    pcall(function()
                        startDrag:FireServer(sapling)
                        sapling:SetPrimaryPartCFrame(CFrame.new(pos))
                        requestPlant:InvokeServer(sapling, pos)
                        stopDrag:FireServer(sapling)
                    end)
                end

                table.insert(reservedPositions, pos)
                angle = angle + angleStep
                getgenv().lastCircleAngle = angle
                task.wait(0.1)
            end

            StarterGui:SetCore("SendNotification", {
                Title = "SpamX Notification",
                Text = "All Saplings Planted in Circle",
                Duration = 4
            })
        end)
    end
})

Tab = Window:Tab({
    Title = "Fun Features",
    Icon = "play",
    Locked = false,
})

Button = Tab:Button({
    Title = "Teleport All Trees To You",
    Desc = "A button to basically teleport all the trees next to you!",
    Locked = false,
    Callback = function()
        Players = game:GetService("Players")
        Workspace = game:GetService("Workspace")

        player = Players.LocalPlayer
        character = player.Character or player.CharacterAdded:Wait()
        hrp = character:WaitForChild("HumanoidRootPart")

        frontPos = hrp.Position + (hrp.CFrame.LookVector * 10)

        for _, obj in pairs(Workspace:GetDescendants()) do
            if obj:IsA("Model") and obj.Name == "Small Tree" then
                if not obj.PrimaryPart then
                    base = obj:FindFirstChildWhichIsA("BasePart")
                    if base then
                        obj.PrimaryPart = base
                    else
                        continue
                    end
                end
                obj:SetPrimaryPartCFrame(CFrame.new(frontPos))
            end
        end
    end
})

Button = Tab:Button({
    Title = "Teleport All Big Trees To You",
    Desc = "a button to basically teleport all big trees next to you",
    Locked = false,
    Callback = function()
        Players = game:GetService("Players")
        Workspace = game:GetService("Workspace")

        player = Players.LocalPlayer
        character = player.Character or player.CharacterAdded:Wait()
        hrp = character:WaitForChild("HumanoidRootPart")

        frontPos = hrp.Position + (hrp.CFrame.LookVector * 10)

        for _, obj in pairs(Workspace:GetDescendants()) do
            if obj:IsA("Model") and string.find(obj.Name, "TreeBig") then
                if not obj.PrimaryPart then
                    base = obj:FindFirstChildWhichIsA("BasePart")
                    if base then
                        obj.PrimaryPart = base
                    else
                        continue
                    end
                end
                obj:SetPrimaryPartCFrame(CFrame.new(frontPos))
            end
        end
    end
})

Button_BringSnowyTrees = Tab:Button({
    Title = "Bring Snowy Small Tree Infront Of You",
    Desc = "A button to basically bring all snowy Small trees next to you",
    Locked = false,
    Callback = function()
        player = game:GetService("Players").LocalPlayer
        char = player.Character or player.CharacterAdded:Wait()
        hrp = char:WaitForChild("HumanoidRootPart")

        frontPos = hrp.Position + (hrp.CFrame.LookVector * 10)

        Workspace = game:GetService("Workspace")
        allDescendants = Workspace:GetDescendants()
        for i = 1, #allDescendants do
            model = allDescendants[i]
            if model:IsA("Model") and model.Name == "Snowy Small Tree" then
                part = model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart")
                if part then
                    model.PrimaryPart = part
                    model:SetPrimaryPartCFrame(CFrame.new(frontPos))
                end
            end
        end
    end
})

Section = Tab:Section({ 
    Title = "Freeze",
    Icon = "snowflake",
    Box = true, 
    FontWeight = Enum.FontWeight.SemiBold,
    TextTransparency = 0,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextSize = 17,
    Opened = true,
})

workspaceCharacters = workspace:WaitForChild("Characters")

FreezeToggle = Tab:Toggle({
    Title = "Freeze All Enemies/Animal",
    Desc = "A Toggle To Basically Freeze All Enemies Or Animals Like Time Stop",
    Icon = "snowflake",
    Type = "Toggle",
    Default = false,
    Callback = function(state)
        children = workspaceCharacters:GetChildren()
        for i = 1, #children do
            model = children[i]
            if model:IsA("Model") then
                parts = model:GetDescendants()
                for j = 1, #parts do
                    part = parts[j]
                    if part:IsA("BasePart") then
                        part.Anchored = state
                    end
                end
            end
        end
    end
})

Section = Tab:Section({ 
    Title = "Chests",
    Icon = "package",
    Box = true, 
    FontWeight = Enum.FontWeight.SemiBold,
    TextTransparency = 0,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextSize = 17,
    Opened = true,
})

Button_BringChests = Tab:Button({
    Title = "Bring All Chests",
    Desc = "Brings all Chests basically like Volcanic Chest and Item Chest!",
    Locked = false,
    Callback = function()
        Players = game:GetService("Players")
        Workspace = game:GetService("Workspace")
        player = Players.LocalPlayer
        character = player.Character or player.CharacterAdded:Wait()
        hrp = character:WaitForChild("HumanoidRootPart")
        frontPos = hrp.Position + (hrp.CFrame.LookVector * 10)

        for _, obj in pairs(Workspace:GetDescendants()) do
            if obj:IsA("Model") and (string.find(obj.Name, "Item Chest") or string.find(obj.Name, "Volcanic")) then
                part = obj.PrimaryPart or obj:FindFirstChildWhichIsA("BasePart")
                if part then
                    obj.PrimaryPart = part
                    obj:SetPrimaryPartCFrame(CFrame.new(frontPos))
                end
            end
        end
    end
})

Section = Tab:Section({ 
    Title = "Kids [BETA]",
    Icon = "baby",
    Box = true, 
    FontWeight = Enum.FontWeight.SemiBold,
    TextTransparency = 0,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextSize = 17,
    Opened = true,
})

Dropdown = Tab:Dropdown({
    Title = "Select Kid Type",
    Values = { "DinoKid", "KrakenKid", "SquidKid", "KoalaKid" },
    Value = "DinoKid",
    Callback = function(option)
        SelectedKid = option
    end
})

Button = Tab:Button({
    Title = "Teleport Selected Kid(s)",
    Desc = "Brings selected kid next to you ",
    Locked = false,
    Callback = function()
        Players = game:GetService("Players")
        Workspace = game:GetService("Workspace")
        player = Players.LocalPlayer
        character = player.Character or player.CharacterAdded:Wait()
        hrp = character:WaitForChild("HumanoidRootPart")
        frontPos = hrp.Position + (hrp.CFrame.LookVector * 10)

        descendants = Workspace:GetDescendants()
        for i = 1, #descendants do
            model = descendants[i]
            if model:IsA("Model") and string.find(model.Name, SelectedKid) then
                part = model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart")
                if part then
                    model.PrimaryPart = part
                    model:SetPrimaryPartCFrame(CFrame.new(frontPos))
                end
            end
        end
    end
})

Section = Tab:Section({ 
    Title = "Summon Map",
    Icon = "map",
    Box = true, 
    FontWeight = Enum.FontWeight.SemiBold,
    TextTransparency = 0,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextSize = 17,
    Opened = true,
})

Tab:Button({
    Title = "Teleport to Steal A Brainrot Map",
    Callback = function()
        local Players = game:GetService("Players")
        local Workspace = game:GetService("Workspace")
        local player = Players.LocalPlayer
        if not player then return end

        local MODEL_ASSET = "rbxassetid://96439444595951"
        local UNIQUE_NAME = "__LOADED_MODEL_96439444595951"
        local TARGET_POS = Vector3.new(0, 6388, 0)
        local TELEPORT_OFFSET = Vector3.new(0, 20, 0)

        local function waitForCharacter(plr, timeout)
            timeout = timeout or 10
            local start = tick()
            while tick() - start <= timeout do
                local ch = plr.Character
                if ch and ch.Parent then return ch end
                task.wait(0.05)
            end
            return plr.Character
        end

        local function getBasePartsAndCenter(model)
            local parts = {}
            local sum = Vector3.new(0,0,0)
            local count = 0
            for _,v in ipairs(model:GetDescendants()) do
                if v:IsA("BasePart") then
                    count = count + 1
                    sum = sum + v.Position
                    parts[#parts+1] = v
                end
            end
            if count == 0 then return parts, nil end
            return parts, sum / count
        end

        local function teleportAboveModel(model, hrp)
            local parts, center = getBasePartsAndCenter(model)
            if not center then
                if typeof(model.GetPivot) == "function" then
                    local ok, pivot = pcall(function() return model:GetPivot() end)
                    if ok and pivot then center = pivot.Position end
                end
            end
            if not center then return false end
            pcall(function()
                hrp.CFrame = CFrame.new(center + TELEPORT_OFFSET)
            end)
            return true
        end

        local character = waitForCharacter(player, 10)
        if not character then return end
        local hrp = character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso")
        if not hrp then return end

        local existing = Workspace:FindFirstChild(UNIQUE_NAME)
        if existing and existing.Parent then
            local ok = pcall(function() 
                if not teleportAboveModel(existing, hrp) then
                    error("Teleport failed.")
                end
            end)
            if ok then return else existing = nil end
        end

        local okLoad, loaded = pcall(function() return game:GetObjects(MODEL_ASSET)[1] end)
        if not okLoad or not loaded then return end
        loaded.Name = UNIQUE_NAME
        loaded.Parent = Workspace

        local parts, center = getBasePartsAndCenter(loaded)
        if center then
            local delta = TARGET_POS - center
            local anchorStates = {}
            for _,p in ipairs(parts) do
                anchorStates[p] = p.Anchored
                p.Anchored = true
                p.CFrame = p.CFrame + delta
            end
            for p,st in pairs(anchorStates) do
                if p and p.Parent then p.Anchored = st end
            end
        else
            local placed = false
            pcall(function()
                if typeof(loaded.PivotTo) == "function" then
                    loaded:PivotTo(CFrame.new(TARGET_POS))
                    placed = true
                end
            end)
            if not placed then
                for _,v in ipairs(loaded:GetDescendants()) do
                    if v:IsA("BasePart") then
                        pcall(function() loaded.PrimaryPart = v end)
                        break
                    end
                end
                pcall(function()
                    if loaded.PrimaryPart then
                        loaded:SetPrimaryPartCFrame(CFrame.new(TARGET_POS))
                        placed = true
                    end
                end)
            end
        end

        teleportAboveModel(loaded, hrp)
    end
})

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local player = Players.LocalPlayer
if not player then return end

local MODEL_ASSET = "rbxassetid://105019154044298"
local UNIQUE_NAME = "__LOADED_MODEL_105019154044298"
local TARGET_POS = Vector3.new(0, 65782, 0)
local TELEPORT_OFFSET = Vector3.new(0, 20, 0)

local function waitForCharacter(plr, timeout)
    local start = tick()
    while tick() - start <= (timeout or 10) do
        if plr.Character and plr.Character.Parent then
            return plr.Character
        end
        task.wait(0.05)
    end
    return plr.Character
end

local function getPartsAndCenter(model)
    local parts, sum, count = {}, Vector3.new(), 0
    for _,v in ipairs(model:GetDescendants()) do
        if v:IsA("BasePart") then
            count += 1
            sum += v.Position
            parts[#parts+1] = v
        end
    end
    return parts, (count > 0 and sum / count or nil)
end

local function teleportAboveModel(model, hrp)
    local _, center = getPartsAndCenter(model)
    if not center then
        if typeof(model.GetPivot) == "function" then
            local ok, pivot = pcall(function() return model:GetPivot() end)
            if ok and pivot then center = pivot.Position end
        end
    end
    if center then
        pcall(function()
            hrp.CFrame = CFrame.new(center + TELEPORT_OFFSET)
        end)
    end
end

local function loadAndTeleport()
    local character = waitForCharacter(player, 10)
    if not character then return end
    local hrp = character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso")
    if not hrp then return end

    local existing = Workspace:FindFirstChild(UNIQUE_NAME)
    if existing then
        teleportAboveModel(existing, hrp)
        return
    end

    local ok, model = pcall(function()
        return game:GetObjects(MODEL_ASSET)[1]
    end)
    if not ok or not model then return end

    model.Name = UNIQUE_NAME
    model.Parent = Workspace

    local parts, center = getPartsAndCenter(model)
    if center then
        local delta = TARGET_POS - center
        local anchors = {}
        for _,p in ipairs(parts) do
            anchors[p] = p.Anchored
            p.Anchored = true
            p.CFrame = p.CFrame + delta
        end
        for p,st in pairs(anchors) do
            if p and p.Parent then
                p.Anchored = st
            end
        end
    else
        pcall(function()
            if typeof(model.PivotTo) == "function" then
                model:PivotTo(CFrame.new(TARGET_POS))
            elseif model.PrimaryPart then
                model:SetPrimaryPartCFrame(CFrame.new(TARGET_POS))
            else
                for _,v in ipairs(model:GetDescendants()) do
                    if v:IsA("BasePart") then
                        model.PrimaryPart = v
                        model:SetPrimaryPartCFrame(CFrame.new(TARGET_POS))
                        break
                    end
                end
            end
        end)
    end

    teleportAboveModel(model, hrp)
end

Tab:Button({
    Title = "Teleport to Grow A Garden",
    Desc = "Teleport to Grow a gArden ahah",
    Callback = function()
        task.spawn(loadAndTeleport)
    end
})

Tab:Button({
    Title = "Teleport to Prison Life",
    Callback = function()
        local Players = game:GetService("Players")
        local Workspace = game:GetService("Workspace")
        local player = Players.LocalPlayer
        if not player then return end

        local MODEL_ASSET = "rbxassetid://13820453861"
        local UNIQUE_NAME = "__LOADED_MODEL_13820453861"
        local TARGET_POS = Vector3.new(0, 67379, 127)
        local TELEPORT_OFFSET = Vector3.new(0, 20, 0)

        local function waitForCharacter(plr, timeout)
            local start = tick()
            while tick() - start <= (timeout or 10) do
                if plr.Character and plr.Character.Parent then
                    return plr.Character
                end
                task.wait(0.05)
            end
            return plr.Character
        end

        local function getPartsAndCenter(model)
            local parts, sum, count = {}, Vector3.new(), 0
            for _,v in ipairs(model:GetDescendants()) do
                if v:IsA("BasePart") then
                    count += 1
                    sum += v.Position
                    parts[#parts+1] = v
                end
            end
            return parts, (count > 0 and sum / count or nil)
        end

        local function teleportAboveModel(model, hrp)
            local _, center = getPartsAndCenter(model)
            if not center then
                if typeof(model.GetPivot) == "function" then
                    local ok, pivot = pcall(function() return model:GetPivot() end)
                    if ok and pivot then center = pivot.Position end
                end
            end
            if center then
                pcall(function()
                    hrp.CFrame = CFrame.new(center + TELEPORT_OFFSET)
                end)
            end
        end

        local character = waitForCharacter(player, 10)
        if not character then return end
        local hrp = character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso")
        if not hrp then return end

        local existing = Workspace:FindFirstChild(UNIQUE_NAME)
        if existing then
            teleportAboveModel(existing, hrp)
            return
        end

        local ok, model = pcall(function()
            return game:GetObjects(MODEL_ASSET)[1]
        end)
        if not ok or not model then return end

        model.Name = UNIQUE_NAME
        model.Parent = Workspace

        local parts, center = getPartsAndCenter(model)
        if center then
            local delta = TARGET_POS - center
            local anchors = {}
            for _,p in ipairs(parts) do
                anchors[p] = p.Anchored
                p.Anchored = true
                p.CFrame = p.CFrame + delta
            end
            for p,st in pairs(anchors) do
                if p and p.Parent then
                    p.Anchored = st
                end
            end
        else
            pcall(function()
                if typeof(model.PivotTo) == "function" then
                    model:PivotTo(CFrame.new(TARGET_POS))
                elseif model.PrimaryPart then
                    model:SetPrimaryPartCFrame(CFrame.new(TARGET_POS))
                else
                    for _,v in ipairs(model:GetDescendants()) do
                        if v:IsA("BasePart") then
                            model.PrimaryPart = v
                            model:SetPrimaryPartCFrame(CFrame.new(TARGET_POS))
                            break
                        end
                    end
                end
            end)
        end

        teleportAboveModel(model, hrp)
    end
})

Tab = Window:Tab({
    Title = "Bring Stuff",
    Icon = "maximize-2",
    Locked = false,
})

Players = game:GetService("Players")
RS = game:GetService("ReplicatedStorage")
WorkspaceItems = workspace:WaitForChild("Items")
TweenService = game:GetService("TweenService")

StartDrag = RS:WaitForChild("RemoteEvents"):WaitForChild("RequestStartDraggingItem")
StopDrag = RS:WaitForChild("RemoteEvents"):WaitForChild("StopDraggingItem")

LP = Players.LocalPlayer
HRP = LP.Character and LP.Character:FindFirstChild("HumanoidRootPart")
LP.CharacterAdded:Connect(function(c)
    HRP = c:WaitForChild("HumanoidRootPart")
end)

TargetCFrame = "Myself"
BringSpeed = "Instant"
BringCount = 1
BringCooldown = 0.1

function GetTargetCFrame(target)
    if target == "Myself" then
        return HRP.CFrame
    elseif target == "Fire" then
        return CFrame.new(0,10,0)
    elseif target == "Workbench" then
        return CFrame.new(21,14,-5)
    else
        local plr = Players:FindFirstChild(target)
        if plr and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
            return plr.Character.HumanoidRootPart.CFrame
        end
    end
    return HRP.CFrame
end

function BringItems(itemsTable)
    origCFrame = HRP.CFrame
    count = tonumber(BringCount) or 1
    cooldown = tonumber(BringCooldown) or 0.1
    for _, itemName in ipairs(itemsTable) do
        itemsBrought = 0
        for _, item in ipairs(WorkspaceItems:GetChildren()) do
            if itemsBrought >= count then break end
            if item.Name == itemName then
                part = item:IsA("Model") and (item.PrimaryPart or item:FindFirstChildWhichIsA("BasePart") or item:FindFirstChild("Handle")) or item
                if part then
                    if item:IsA("Model") and not item.PrimaryPart then
                        pcall(function() item.PrimaryPart = part end)
                    end
                    pcall(function()
                        StartDrag:FireServer(item)
                        targetCF = GetTargetCFrame(TargetCFrame)
                        if BringSpeed == "Tween" then
                            info = TweenInfo.new(0.2, Enum.EasingStyle.Linear)
                            TweenService:Create(HRP, info, {CFrame = part.CFrame + Vector3.new(0,3,0)}):Play()
                            task.wait(0.2)
                        end
                        if item:IsA("Model") then
                            item:SetPrimaryPartCFrame(targetCF)
                        else
                            part.CFrame = targetCF
                        end
                        if BringSpeed == "Tween" then
                            HRP.CFrame = origCFrame
                        end
                        StopDrag:FireServer(item)
                    end)
                    itemsBrought = itemsBrought + 1
                    task.wait(cooldown)
                end
            end
        end
    end
end

function GetPlayerList()
    list = {"Myself","Fire","Workbench"}
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LP then
            table.insert(list, plr.Name)
        end
    end
    return list
end

Tab:Dropdown({
    Title = "Select Target",
    Values = GetPlayerList(),
    Value = "Myself",
    Multi = false,
    Callback = function(val) TargetCFrame = val end
})

Tab:Dropdown({
    Title = "Bring Speed",
    Values = {"Instant","Tween"},
    Value = "Instant",
    Multi = false,
    Callback = function(val) BringSpeed = val end
})

Tab:Input({Title = "Item Count", Value = "1", Callback = function(val) BringCount = tonumber(val) or 1 end})
Tab:Input({Title = "Bring Cooldown", Value = "0.1", Callback = function(val) BringCooldown = tonumber(val) or 0.1 end})

Tab:Section({Title="Bring Fuel", Box=false, FontWeight=Enum.FontWeight.SemiBold, TextTransparency=0, TextXAlignment=Enum.TextXAlignment.Left, TextSize=17, Opened=true})
Tab:Dropdown({Title="Select Fuel Items", Values={"Sapling","Log","Chair","Fuel Canister","Oil Barrel","Biofuel","Cultist Corpse","Crossbow Cultist Corpse","Juggernaut Cultist Corpse","Wolf Corpse","Alpha Wolf Corpse","Bear Corpse"}, Value={"Sapling"}, Multi=true, Callback=function(val) FuelSelected = val end})
Tab:Button({Title="Bring Fuel Items", Callback=function() BringItems(FuelSelected or {"Sapling"}) end})
Tab:Button({Title="Bring All Logs", Callback=function() BringItems({"Log"}) end})

Tab:Section({Title="Bring Scraps", Box=false, FontWeight=Enum.FontWeight.SemiBold, TextTransparency=0, TextXAlignment=Enum.TextXAlignment.Left, TextSize=17, Opened=true})
Tab:Dropdown({Title="Select Scrap Items", Values={"Bolt","Sheet Metal","Broken Fan","Old Radio","Metal Chair","Old Microwave","Tyre","Old Car Engine","Washing Machine","Cultist Prototype","Cultist Experiment","Cultist Gem","Forest Gem"}, Value={"Bolt"}, Multi=true, Callback=function(val) ScrapsSelected = val end})
Tab:Button({Title="Bring Scraps", Callback=function() BringItems(ScrapsSelected or {"Bolt"}) end})

Tab:Section({Title="Bring Food", Box=false, FontWeight=Enum.FontWeight.SemiBold, TextTransparency=0, TextXAlignment=Enum.TextXAlignment.Left, TextSize=17, Opened=true})
Tab:Dropdown({Title="Select Food Items", Values={"Carrot","Berry","Chili","Bandage","Medkit","Morsel","Steak","Cooked Morsel","Cooked Steak","Morsel?","Cake","Stew","Hearty Stew","Ribs","Cooked Ribs","Carrot Cake","BBQ Ribs"}, Value={"Carrot"}, Multi=true, Callback=function(val) FoodSelected = val end})
Tab:Button({Title="Bring Food", Callback=function() BringItems(FoodSelected or {"Carrot"}) end})

Tab:Section({Title="Bring Tools", Box=false, FontWeight=Enum.FontWeight.SemiBold, TextTransparency=0, TextXAlignment=Enum.TextXAlignment.Left, TextSize=17, Opened=true})
Tab:Dropdown({Title="Select Tools", Values={"Good Axe","Strong Axe","Good Sack","Giant Sack","Infernal Sack","Old flashlight","Strong Flashlight","Ice Axe","Chainsaw"}, Value={"Good Axe"}, Multi=true, Callback=function(val) ToolsSelected = val end})
Tab:Button({Title="Bring Tools", Callback=function() BringItems(ToolsSelected or {"Good Axe"}) end})

Tab:Section({Title="Bring Armor & Melee", Box=false, FontWeight=Enum.FontWeight.SemiBold, TextTransparency=0, TextXAlignment=Enum.TextXAlignment.Left, TextSize=17, Opened=true})
Tab:Dropdown({Title="Select Armor/Melee", Values={"Spear","Katana","Morningstar","Blowpipe","Laser Sword","Ice Sword","Poison Spear","Infernal Sword","Cultist King Mace","Obsidiron Hammer","Leather Body","Iron Body","Thorn Body","Poison Armor","Alien Armor","Obsidiron Body","Riot Shield"}, Value={"Spear"}, Multi=true, Callback=function(val) ArmorSelected = val end})
Tab:Button({Title="Bring Armor/Melee", Callback=function() BringItems(ArmorSelected or {"Spear"}) end})

Tab:Section({Title="Bring Ranged Weapons & Ammo", Box=false, FontWeight=Enum.FontWeight.SemiBold, TextTransparency=0, TextXAlignment=Enum.TextXAlignment.Left, TextSize=17, Opened=true})
Tab:Dropdown({Title="Select Ranged Items", Values={"Revolver","Rifle","Tactical Shotgun","Revolver Ammo","Rifle Ammo","Shotgun Ammo","Snowball","Kunai","Frozen Shuriken","Wildfire","Crossbow","Infernal Crossbow","Flamethrower","Raygun","Laser Cannon"}, Value={"Revolver"}, Multi=true, Callback=function(val) RangedSelected = val end})
Tab:Button({Title="Bring Ranged Items", Callback=function() BringItems(RangedSelected or {"Revolver"}) end})

Tab:Section({Title="Bring Other Items", Box=false, FontWeight=Enum.FontWeight.SemiBold, TextTransparency=0, TextXAlignment=Enum.TextXAlignment.Left, TextSize=17, Opened=true})
Tab:Dropdown({Title="Select Other Items", Values={"Seed Box","Wolf Pelt","Alpha Wolf Pelt","Bear Pelt","Artic Fox Pelt","Polar Bear Pelt","Mammoth Tusk","Scorpion Shell","Cultist King Antler","FrogKey","Hammer","Paint Brush","Forest Gem Fragment","Mossy coin","Coin Stack","Sacrifice Totem","Meteor Shard","Gold Shard","Obsidiron Ingot","RedKey","BlueKey","YellowKey","GreyKey","Anvil Front","Anvil Back","Anvil Base"}, Value={"Seed Box"}, Multi=true, Callback=function(val) OtherSelected = val end})
Tab:Button({Title="Bring Other Items", Callback=function() BringItems(OtherSelected or {"Seed Box"}) end})

Tab = Window:Tab({
    Title = "Hitbox/Aimbot",
    Icon = "expand",
    Locked = false,
})

Players = game:GetService("Players")
Workspace = game:GetService("Workspace")
RunService = game:GetService("RunService")

HitboxStudSize = 30
HitboxEnabled = false
ShowHitboxes = false

Tab:Slider({
    Title = "Hitbox Size (Studs)",
    Value = {Min = 10, Max = 150, Default = 30},
    Step = 5,
    Callback = function(val)
        HitboxStudSize = val
    end
})

Tab:Toggle({
    Title = "Enable Expanded Hitboxes",
    Default = false,
    Callback = function(state)
        HitboxEnabled = state
    end
})

Tab:Toggle({
    Title = "Show Hitboxes",
    Default = false,
    Callback = function(state)
        ShowHitboxes = state
    end
})

function CreateHitbox(model)
    local part = Instance.new("Part")
    part.Name = "NiggaEriCShitBox"
    part.Anchored = true
    part.CanCollide = false
    part.Material = Enum.Material.Neon
    part.Color = Color3.fromRGB(255, 60, 60)
    part.Size = Vector3.new(HitboxStudSize, HitboxStudSize, HitboxStudSize)
    part.Transparency = ShowHitboxes and 0.4 or 1
    part.Parent = model
    return part
end

RunService.RenderStepped:Connect(function()
    if not Workspace:FindFirstChild("Characters") then return end
    for _, model in ipairs(Workspace.Characters:GetChildren()) do
        if model:IsA("Model") then
            local hrp = model:FindFirstChild("HumanoidRootPart")
            if hrp then
                local hb = model:FindFirstChild("NiggaEriCShitBox")
                if HitboxEnabled then
                    if not hb then
                        hb = CreateHitbox(model)
                    end
                    hb.Size = Vector3.new(HitboxStudSize, HitboxStudSize, HitboxStudSize)
                    hb.Transparency = ShowHitboxes and 0.4 or 1
                    hb.CFrame = hrp.CFrame
                elseif hb then
                    hb:Destroy()
                end
            end
        end
    end
end)

Section = Tab:Section({ 
    Title = "Aimbot",
    Icon = "crosshair",
    Box = true, 
    FontWeight = Enum.FontWeight.SemiBold,
    TextTransparency = 0,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextSize = 17,
    Opened = true,
})

Button = Tab:Button({
    Title = "Silent Aimbot Coming Soon",
    Desc = nil,
    Locked = false,
    Callback = function() end
})

Tab = Window:Tab({
    Title = "Taming/Fishing",
    Icon = "fish-symbol",
    Locked = false,
})

SuccessAreaTallEnabled = false

Tab:Toggle({
    Title = "100% Success Tame",
    Default = false,
    Callback = function(state)
        SuccessAreaTallEnabled = state
    end
})

game:GetService("RunService").RenderStepped:Connect(function()
    if SuccessAreaTallEnabled then
        local player = game.Players.LocalPlayer
        if not player then return end

        local interface = player.PlayerGui:FindFirstChild("Interface")
        if not interface then return end

        local tameFrame = interface:FindFirstChild("TamingFluteFrame")
        if not tameFrame or not tameFrame.Visible then return end

        local timingBar = tameFrame:FindFirstChild("TimingBar")
        if not timingBar then return end

        local successArea = timingBar:FindFirstChild("SuccessArea")
        if successArea then
            local width = successArea.Size.X
            successArea.Size = UDim2.new(width.Scale, width.Offset, 0, 225)
        end
    end
end)

Tab:Button({
    Title = "Bring Steak",
    Desc = nil,
    Locked = false,
    Callback = function()
        Players = game:GetService("Players")
        WorkspaceItems = workspace:WaitForChild("Items")
        RS = game:GetService("ReplicatedStorage")

        StartDrag = RS:WaitForChild("RemoteEvents"):WaitForChild("RequestStartDraggingItem")
        StopDrag = RS:WaitForChild("RemoteEvents"):WaitForChild("StopDraggingItem")

        player = Players.LocalPlayer
        hrp = player.Character:WaitForChild("HumanoidRootPart")

        function BringItem(itemName)
            for _, item in ipairs(WorkspaceItems:GetChildren()) do
                if item.Name == itemName then
                    part = item:IsA("Model") and (item.PrimaryPart or item:FindFirstChildWhichIsA("BasePart") or item:FindFirstChild("Handle")) or item
                    if part then
                        if item:IsA("Model") and not item.PrimaryPart then
                            pcall(function() item.PrimaryPart = part end)
                        end

                        pcall(function()
                            StartDrag:FireServer(item)
                            if item:IsA("Model") then
                                item:SetPrimaryPartCFrame(hrp.CFrame)
                            else
                                part.CFrame = hrp.CFrame
                            end
                            StopDrag:FireServer(item)
                        end)

                        break
                    end
                end
            end
        end

        BringItem("Steak")
    end
})

Tab:Button({
    Title = "Bring Carrot",
    Desc = nil,
    Locked = false,
    Callback = function()
        Players = game:GetService("Players")
        WorkspaceItems = workspace:WaitForChild("Items")
        RS = game:GetService("ReplicatedStorage")

        StartDrag = RS:WaitForChild("RemoteEvents"):WaitForChild("RequestStartDraggingItem")
        StopDrag = RS:WaitForChild("RemoteEvents"):WaitForChild("StopDraggingItem")

        player = Players.LocalPlayer
        hrp = player.Character:WaitForChild("HumanoidRootPart")

        function BringItem(itemName)
            for _, item in ipairs(WorkspaceItems:GetChildren()) do
                if item.Name == itemName then
                    part = item:IsA("Model") and (item.PrimaryPart or item:FindFirstChildWhichIsA("BasePart") or item:FindFirstChild("Handle")) or item
                    if part then
                        if item:IsA("Model") and not item.PrimaryPart then
                            pcall(function() item.PrimaryPart = part end)
                        end

                        pcall(function()
                            StartDrag:FireServer(item)
                            if item:IsA("Model") then
                                item:SetPrimaryPartCFrame(hrp.CFrame)
                            else
                                part.CFrame = hrp.CFrame
                            end
                            StopDrag:FireServer(item)
                        end)

                        break
                    end
                end
            end
        end

        BringItem("Carrot")
    end
})

Tab:Button({
    Title = "Teleport to Taming Tent",
    Desc = nil,
    Callback = function()
        player = game.Players.LocalPlayer
        hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end

        tamingTent = workspace:FindFirstChild("Map") 
            and workspace.Map:FindFirstChild("Landmarks") 
            and workspace.Map.Landmarks:FindFirstChild("Taming Tent")

        if tamingTent then
            part = tamingTent:FindFirstChildWhichIsA("BasePart")
            if part then
                hrp.CFrame = part.CFrame + Vector3.new(0, 5, 0)
            else
                warn("Taming Tent has no parts to teleport to!")
            end
        else
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "SpamX Reminder",
                Text = "Taming Tent not found! Explore the map so it loads.",
                Duration = 5
            })
        end
    end
})

Section = Tab:Section({ 
    Title = "Fishing",
    Icon = "fish",
    Box = true, 
    FontWeight = Enum.FontWeight.SemiBold,
    TextTransparency = 0,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextSize = 17,
    Opened = true,
})


Tab:Toggle({  
    Title = "Auto Catch Minigame",  
    Default = false,  
    Callback = function(state)  
        getgenv().autoCatchEnabled = state  
        if state then  
            getgenv().wasInZone = false  
            getgenv().autoCatchConnection = game:GetService("RunService").Heartbeat:Connect(function()  
                local success, err = pcall(function()  
                    player = game.Players.LocalPlayer  
                    if not player then return end  
                    interface = player.PlayerGui:FindFirstChild("Interface") or player:FindFirstChild("Interface")  
                    if not interface then return end  
                    fishingFrame = interface:FindFirstChild("FishingCatchFrame")  
                    if not fishingFrame or not fishingFrame.Visible then   
                        getgenv().wasInZone = false  
                        return   
                    end  
                    timingBar = fishingFrame:FindFirstChild("TimingBar")  
                    if not timingBar then return end  
                    bar = timingBar:FindFirstChild("Bar")  
                    successArea = timingBar:FindFirstChild("SuccessArea")  
                    if not bar or not successArea then return end  
                    barPos = bar.AbsolutePosition  
                    barSize = bar.AbsoluteSize  
                    successPos = successArea.AbsolutePosition  
                    successSize = successArea.AbsoluteSize  
                    xOverlap = barPos.X < successPos.X + successSize.X and barPos.X + barSize.X > successPos.X  
                    yOverlap = barPos.Y < successPos.Y + successSize.Y and barPos.Y + barSize.Y > successPos.Y  
                    inZone = xOverlap and yOverlap  
                    if inZone and not getgenv().wasInZone then  
                        vim = game:GetService("VirtualInputManager")  
                        vim:SendMouseButtonEvent(0, 0, 0, true, game, 1)  
                        task.wait(0.03)  
                        vim:SendMouseButtonEvent(0, 0, 0, false, game, 1)  
                    end  
                    getgenv().wasInZone = inZone  
                end)  
                if not success then warn("Auto Catch Error:", err) end  
            end)  
        else  
            if getgenv().autoCatchConnection then  
                getgenv().autoCatchConnection:Disconnect()  
                getgenv().autoCatchConnection = nil  
            end  
            getgenv().wasInZone = false  
        end  
    end  
})

Tab:Toggle({
    Title = "100% Catch Chance",
    Default = false,
    Callback = function(state)
        getgenv().GreenBarHeightEnabled = state
        
        if state then
            getgenv().GreenBarConnection = game:GetService("RunService").RenderStepped:Connect(function()
                player = game.Players.LocalPlayer
                if not player then return end
                interface = player.PlayerGui:FindFirstChild("Interface") or player:FindFirstChild("Interface")
                if not interface then return end
                fishingFrame = interface:FindFirstChild("FishingCatchFrame")
                if not fishingFrame or not fishingFrame.Visible then return end
                timingBar = fishingFrame:FindFirstChild("TimingBar")
                if not timingBar then return end
                successArea = timingBar:FindFirstChild("SuccessArea")
                if successArea then
                    width = successArea.Size.X
                    successArea.Size = UDim2.new(width.Scale, width.Offset, 0, 80)
                end
            end)
        else
            if getgenv().GreenBarConnection then
                getgenv().GreenBarConnection:Disconnect()
                getgenv().GreenBarConnection = nil
            end
        end
    end
})

ToggleCatchEnabled = false

Tab:Toggle({
    Title = "Instant Catch",
    Default = false,
    Callback = function(state)
        ToggleCatchEnabled = state
        if state then
            if not getgenv().CatchConnection then
                ReplicatedStorage = game:GetService("ReplicatedStorage")
                remoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
                startCatchTimer = remoteEvents:WaitForChild("StartCatchTimer")
                confirmCatchItem = remoteEvents:WaitForChild("ConfirmCatchItem")

                getgenv().CatchConnection = startCatchTimer.OnClientEvent:Connect(function()
                    if ToggleCatchEnabled then
                        confirmCatchItem:FireServer()
                    end
                end)
            end
        else
            if getgenv().CatchConnection then
                getgenv().CatchConnection:Disconnect()
                getgenv().CatchConnection = nil
            end
        end
    end
})

Tab:Button({
    Title = "Teleport to Fishing Hut",
    Desc = "Teleports you to the fishing hut where you get fishing rod ifykyk imo",
    Callback = function()
        local player = game.Players.LocalPlayer
        if not player or not player.Character then return end

        local hrp = player.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end

        local fishingHut = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Landmarks") and workspace.Map.Landmarks:FindFirstChild("Fishing Hut")
        if fishingHut then
            local part = fishingHut:FindFirstChildWhichIsA("BasePart")
            if part then
                hrp.CFrame = part.CFrame + Vector3.new(0, 5, 0)
            else
                warn("Fishing Hut has no parts to teleport to!")
            end
        else
            warn("Fishing Hut not found in workspace.Map.Landmarks!")
        end
    end
})

Tab = Window:Tab({
    Title = "esp",
    Icon = "eye",
    Locked = false,
})

local ESPEnabled = false
local ESPColor = Color3.fromRGB(255,255,0)

local selectedFuel = {}
local selectedScrap = {}
local selectedFood = {}
local selectedTools = {}
local selectedMelee = {}
local selectedRanged = {}
local selectedOthers = {}

Tab:Toggle({
    Title = "ESP Enabled",
    Default = false,
    Callback = function(state)
        ESPEnabled = state
    end
})

Tab:Colorpicker({
    Title = "ESP Color",
    Default = Color3.fromRGB(255,255,0),
    Callback = function(color)
        ESPColor = color
    end
})

Tab:Dropdown({
    Title = "Select Fuel",
    Values = {"Log","Coal","Chair","Fuel Canister","Oil Barrel","Biofuel","Wolf Corpse","Alpha Wolf Corpse","Bear Corpse","Cultist Corpse","Crossbow Cultist Corpse"},
    Multi = true,
    Callback = function(val) selectedFuel = val end
})

Tab:Dropdown({
    Title = "Select Scrap",
    Values = {"Bolt","Sheet Metal","Broken Fan","Old Radio","Broken Microwave","Tyre","Metal Chair","Old Car Engine","Washing Machine","Cultist Experiment","Cultist Prototype"},
    Multi = true,
    Callback = function(val) selectedScrap = val end
})

Tab:Dropdown({
    Title = "Select Food",
    Values = {"Carrot","Berry","Chili","Bandage","Medkit","Morsel","Steak","Cooked Morsel","Cooked Steak","Morsel?","Cake","Stew","Hearty Stew","Ribs","Cooked Ribs","Carrot Cake","BBQ Ribs"},
    Multi = true,
    Callback = function(val) selectedFood = val end
})

Tab:Dropdown({
    Title = "Select Tools",
    Values = {"Good Axe","Strong Axe","Good Sack","Giant Sack","Infernal Sack","Old flashlight","Strong Flashlight","Ice Axe","Chainsaw"},
    Multi = true,
    Callback = function(val) selectedTools = val end
})

Tab:Dropdown({
    Title = "Select Melee/Armor",
    Values = {"Spear","Katana","Morningstar","Blowpipe","Laser Sword","Ice Sword","Poison Spear","Infernal Sword","Cultist King Mace","Obsidiron Hammer","Leather Body","Iron Body","Thorn Body","Poison Armor","Alien Armor","Obsidiron Body","Riot Shield"},
    Multi = true,
    Callback = function(val) selectedMelee = val end
})

Tab:Dropdown({
    Title = "Select Ranged/Ammo",
    Values = {"Revolver","Rifle","Tactical Shotgun","Revolver Ammo","Rifle Ammo","Shotgun Ammo","Snowball","Kunai","Frozen Shuriken","Wildfire","Crossbow","Infernal Crossbow","Flamethrower","Raygun","Laser Cannon"},
    Multi = true,
    Callback = function(val) selectedRanged = val end
})

Tab:Dropdown({
    Title = "Select Others",
    Values = {"Seed Box","Wolf Pelt","Alpha Wolf Pelt","Bear Pelt","Artic Fox Pelt","Polar Bear Pelt","Mammoth Tusk","Scorpion Shell","Cultist King Antler","FrogKey","Hammer","Paint Brush","Forest Gem Fragment","Mossy coin","Coin Stack","Sacrifice Totem","Meteor Shard","Gold Shard","Obsidiron Ingot","RedKey","BlueKey","YellowKey","GreyKey","Anvil Front","Anvil Back","Anvil Base"},
    Multi = true,
    Callback = function(val) selectedOthers = val end
})

task.spawn(function()
    while true do
        if ESPEnabled then
            local itemsTable = workspace:WaitForChild("Items"):GetChildren()
            local allSelected = {}
            for _,v in ipairs(selectedFuel) do allSelected[v] = true end
            for _,v in ipairs(selectedScrap) do allSelected[v] = true end
            for _,v in ipairs(selectedFood) do allSelected[v] = true end
            for _,v in ipairs(selectedTools) do allSelected[v] = true end
            for _,v in ipairs(selectedMelee) do allSelected[v] = true end
            for _,v in ipairs(selectedRanged) do allSelected[v] = true end
            for _,v in ipairs(selectedOthers) do allSelected[v] = true end

            for _, item in ipairs(itemsTable) do
                if allSelected[item.Name] then
                    local part = item:IsA("Model") and (item.PrimaryPart or item:FindFirstChildWhichIsA("BasePart") or item:FindFirstChild("Handle")) or item
                    if part then
                        local billboard = item:FindFirstChild("ESPLabel")
                        if not billboard then
                            billboard = Instance.new("BillboardGui")
                            billboard.Name = "ESPLabel"
                            billboard.Adornee = part
                            billboard.Size = UDim2.new(0,100,0,40)
                            billboard.StudsOffset = Vector3.new(0,3,0)
                            billboard.AlwaysOnTop = true
                            local text = Instance.new("TextLabel", billboard)
                            text.Size = UDim2.new(1,0,1,0)
                            text.BackgroundTransparency = 1
                            text.TextColor3 = ESPColor
                            text.TextStrokeTransparency = 0
                            text.TextScaled = true
                            text.Text = item.Name
                            billboard.Parent = item
                        end
                        local label = billboard:FindFirstChildOfClass("TextLabel")
                        if label then
                            label.TextColor3 = ESPColor
                            local dist = (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - part.Position).Magnitude
                            label.Text = item.Name .. "\n[" .. math.floor(dist) .. "m]"
                        end
                    end
                else
                    if item:FindFirstChild("ESPLabel") then
                        item.ESPLabel:Destroy()
                    end
                end
            end
        end
        task.wait(0.1)
    end
end)

Tab = Window:Tab({
    Title = "Player",
    Icon = "eye",
    Locked = false,
})

-- WalkSpeed globals (so no local register issues)
getgenv().WalkSpeedEnabled = false
getgenv().WalkSpeedValue = 70

-- Slider (controls WalkSpeed value)
Tab:Slider({
    Title = "WalkSpeed",
    Step = 1,
    Value = {
        Min = 15,
        Max = 500,
        Default = 70,
    },
    Callback = function(value)
        getgenv().WalkSpeedValue = value
        if getgenv().WalkSpeedEnabled then
            local player = game:GetService("Players").LocalPlayer
            local char = player.Character
            if char then
                local hum = char:FindFirstChildOfClass("Humanoid")
                if hum then
                    hum.WalkSpeed = value
                end
            end
        end
    end
})

-- Toggle (enables/disables custom WalkSpeed)
Tab:Toggle({
    Title = "Enable WalkSpeed",
    Icon = "gauge",
    Type = "Toggle",
    Default = false,
    Callback = function(state)
        getgenv().WalkSpeedEnabled = state

        local player = game:GetService("Players").LocalPlayer
        local char = player.Character
        if not char then return end

        local hum = char:FindFirstChildOfClass("Humanoid")
        if not hum then return end

        if state then
            hum.WalkSpeed = getgenv().WalkSpeedValue
        else
            hum.WalkSpeed = 16 -- default Roblox walkspeed
        end
    end
})

Section = Tab:Section({ 
    Title = "Jump-power",
    Box = false,
    FontWeight = Enum.FontWeight.SemiBold,
    TextTransparency = 0,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextSize = 17,
    Opened = true,
})

-- JumpPower globals (avoid local register overflow)
getgenv().JumpPowerEnabled = false
getgenv().JumpPowerValue = 50

-- Slider (controls JumpPower amount)
Tab:Slider({
    Title = "JumP-Power",
    Step = 1,
    Value = {
        Min = 25,
        Max = 500,
        Default = 50,
    },
    Callback = function(value)
        getgenv().JumpPowerValue = value
        if getgenv().JumpPowerEnabled then
            local player = game:GetService("Players").LocalPlayer
            local char = player.Character
            if char then
                local hum = char:FindFirstChildOfClass("Humanoid")
                if hum then
                    hum.UseJumpPower = true
                    hum.JumpPower = value
                end
            end
        end
    end
})

-- Toggle (turns JumpPower on/off)
Tab:Toggle({
    Title = "Enable JumP-Power",
    Icon = "chevron-up",
    Type = "Toggle",
    Default = false,
    Callback = function(state)
        getgenv().JumpPowerEnabled = state

        local player = game:GetService("Players").LocalPlayer
        local char = player.Character
        if not char then return end

        local hum = char:FindFirstChildOfClass("Humanoid")
        if not hum then return end

        if state then
            hum.UseJumpPower = true
            hum.JumpPower = getgenv().JumpPowerValue
        else
            hum.JumpPower = 50 -- default Roblox value
        end
    end
})

Section = Tab:Section({ 
    Title = "Fly",
    Box = false,
    FontWeight = Enum.FontWeight.SemiBold,
    TextTransparency = 0,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextSize = 17,
    Opened = true,
})

-- Globals to prevent local register overflow
getgenv().FlyEnabled = false
getgenv().FlySpeed = 70
getgenv().FlyConnection = nil

-- Fly function
function FlyLoop()
    local player = game:GetService("Players").LocalPlayer
    local char = player.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    if not hrp:FindFirstChild("BodyGyro") then
        local bg = Instance.new("BodyGyro", hrp)
        bg.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
        bg.P = 9e4
        bg.CFrame = hrp.CFrame
    end

    if not hrp:FindFirstChild("BodyVelocity") then
        local bv = Instance.new("BodyVelocity", hrp)
        bv.MaxForce = Vector3.new(9e9, 9e9, 9e9)
    end

    -- Start loop
    getgenv().FlyConnection = game:GetService("RunService").RenderStepped:Connect(function()
        if not getgenv().FlyEnabled then return end
        local MoveVector = require(player.PlayerScripts:WaitForChild("PlayerModule"):WaitForChild("ControlModule")):GetMoveVector()
        local cam = workspace.CurrentCamera

        local velocity = Vector3.zero
        velocity += cam.CFrame.RightVector * (MoveVector.X * getgenv().FlySpeed)
        velocity -= cam.CFrame.LookVector * (MoveVector.Z * getgenv().FlySpeed)

        hrp.BodyVelocity.Velocity = velocity
        hrp.BodyGyro.CFrame = CFrame.new(hrp.Position, hrp.Position + cam.CFrame.LookVector)
    end)
end

-- Stop function
function StopFly()
    local player = game:GetService("Players").LocalPlayer
    local char = player.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    if hrp:FindFirstChild("BodyGyro") then hrp.BodyGyro:Destroy() end
    if hrp:FindFirstChild("BodyVelocity") then hrp.BodyVelocity:Destroy() end

    if getgenv().FlyConnection then
        getgenv().FlyConnection:Disconnect()
        getgenv().FlyConnection = nil
    end
end

-- Slider (controls fly speed)
Tab:Slider({
    Title = "Fly Speed",
    Step = 1,
    Value = {
        Min = 15,
        Max = 500,
        Default = 70,
    },
    Callback = function(value)
        getgenv().FlySpeed = value
    end
})

-- Toggle (enables/disables fly)
Tab:Toggle({
    Title = "Enable Fly",
    Icon = "plane",
    Type = "Toggle",
    Default = false,
    Callback = function(state)
        getgenv().FlyEnabled = state
        if state then
            FlyLoop()
        else
            StopFly()
        end
    end
})

Section = Tab:Section({ 
    Title = "Misc",
    Box = false,
    FontWeight = Enum.FontWeight.SemiBold,
    TextTransparency = 0,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextSize = 17,
    Opened = true,
})

-- Globals
getgenv().InfJumpEnabled = false
getgenv().InfJumpConnection = nil

-- Function to toggle Infinite Jump
Tab:Toggle({
    Title = "Infinite Jump",
    Icon = "rabbit",
    Type = "Toggle",
    Default = false,
    Callback = function(state)
        getgenv().InfJumpEnabled = state

        -- Turn on
        if state then
            if getgenv().InfJumpConnection then
                getgenv().InfJumpConnection:Disconnect()
            end

            getgenv().InfJumpConnection = game:GetService("UserInputService").JumpRequest:Connect(function()
                if getgenv().InfJumpEnabled then
                    local player = game:GetService("Players").LocalPlayer
                    local char = player.Character
                    if char and char:FindFirstChildOfClass("Humanoid") then
                        char:FindFirstChildOfClass("Humanoid"):ChangeState(Enum.HumanoidStateType.Jumping)
                    end
                end
            end)

        -- Turn off
        else
            if getgenv().InfJumpConnection then
                getgenv().InfJumpConnection:Disconnect()
                getgenv().InfJumpConnection = nil
            end
        end
    end
})

NoclipToggle = Tab:Toggle({
    Title = "Noclip",
    Icon = "ghost",  -- keeps the icon in the UI
    Type = "Toggle", -- must be under Icon
    Default = false,
    Callback = function(state)
        getgenv().NoclipEnabled = state
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()

        if not character then return end
        local hrp = character:WaitForChild("HumanoidRootPart")
        local humanoid = character:WaitForChild("Humanoid")

        if state then
            -- Enable noclip
            getgenv().NoclipConnection = game:GetService("RunService").Stepped:Connect(function()
                for _, part in ipairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end
            end)
        else
            -- Disable noclip
            if getgenv().NoclipConnection then
                getgenv().NoclipConnection:Disconnect()
                getgenv().NoclipConnection = nil
            end
            -- Reset collisions
            for _, part in ipairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = true
                end
            end
        end
    end
})

-- Populate drop-down with current players
playerNames = {}
for _, p in ipairs(game.Players:GetPlayers()) do
    table.insert(playerNames, p.Name)
end

-- Drop-down for selecting player
selectedPlayer = playerNames[1]  -- default
Dropdown = Tab:Dropdown({
    Title = "Select Player",
    Values = playerNames,
    Value = selectedPlayer,
    Callback = function(option)
        selectedPlayer = option
    end
})

-- Button to teleport to selected player
Button = Tab:Button({
    Title = "Teleport to Player",
    Desc = "Teleport to the selected player",
    Locked = false,
    Callback = function()
        player = game.Players:FindFirstChild(selectedPlayer)
        lp = game.Players.LocalPlayer
        hrp = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")

        if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") and hrp then
            hrp.CFrame = player.Character.HumanoidRootPart.CFrame + Vector3.new(0, 5, 0)
        else
            game.StarterGui:SetCore("SendNotification", {
                Title = "Voidex Error",
                Text = "Player not found or character not loaded.",
                Duration = 5,
            })
        end
    end
})

-- Auto-refresh drop-down list
game.Players.PlayerAdded:Connect(function(p)
    table.insert(playerNames, p.Name)
    Dropdown:Refresh(playerNames)
end)

game.Players.PlayerRemoving:Connect(function(p)
    for i, name in ipairs(playerNames) do
        if name == p.Name then
            table.remove(playerNames, i)
            break
        end
    end
    Dropdown:Refresh(playerNames)
end)

Section = Tab:Section({ 
    Title = "Brightness",
    Box = false,
    FontWeight = Enum.FontWeight.SemiBold,
    TextTransparency = 0,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextSize = 17,
    Opened = true,
})

-- Global toggle
FullBrightEnabled = false

-- Store original lighting values (for turning off)
OriginalLighting = {
    Ambient = game.Lighting.Ambient,
    OutdoorAmbient = game.Lighting.OutdoorAmbient,
    Brightness = game.Lighting.Brightness,
    ClockTime = game.Lighting.ClockTime
}

-- Function to apply full bright
function applyFullBright()
    game.Lighting.Ambient = Color3.fromRGB(255, 255, 255)
    game.Lighting.OutdoorAmbient = Color3.fromRGB(255, 255, 255)
    game.Lighting.Brightness = 2
    game.Lighting.ClockTime = 14
end

-- RunService loop to keep full bright
game:GetService("RunService").RenderStepped:Connect(function()
    if FullBrightEnabled then
        applyFullBright()
    end
end)

-- Toggle
FullBrightToggle = Tab:Toggle({
    Title = "Full Bright",
    Icon = "sun",
    Type = "Toggle",
    Default = false,
    Callback = function(state)
        FullBrightEnabled = state
        if not state then
            -- Restore original lighting
            game.Lighting.Ambient = OriginalLighting.Ambient
            game.Lighting.OutdoorAmbient = OriginalLighting.OutdoorAmbient
            game.Lighting.Brightness = OriginalLighting.Brightness
            game.Lighting.ClockTime = OriginalLighting.ClockTime
        end
    end
})


-- Global toggle
NightToDayEnabled = false

-- Store original clock time to restore
OriginalClockTime = game.Lighting.ClockTime

-- RunService loop to enforce daytime
game:GetService("RunService").RenderStepped:Connect(function()
    if NightToDayEnabled then
        game.Lighting.ClockTime = 14 -- 2 PM, bright day
    end
end)

-- Toggle
NightToDayToggle = Tab:Toggle({
    Title = "Turn Night Into Day",
    Icon = "moon",
    Type = "Toggle",
    Default = false,
    Callback = function(state)
        NightToDayEnabled = state
        if not state then
            game.Lighting.ClockTime = OriginalClockTime -- restore original time
        end
    end
})

-- Global toggle
RemoveFogEnabled = false

-- Store original fog settings
local Lighting = game:GetService("Lighting")
OriginalFogStart = Lighting.FogStart
OriginalFogEnd = Lighting.FogEnd

-- RunService loop to enforce no fog
game:GetService("RunService").RenderStepped:Connect(function()
    if RemoveFogEnabled then
        Lighting.FogStart = 0
        Lighting.FogEnd = 100000 -- effectively removes fog
    end
end)

-- Toggle
RemoveFogToggle = Tab:Toggle({
    Title = "Remove Fog",
    Icon = "eye-off",
    Type = "Toggle",
    Default = false,
    Callback = function(state)
        RemoveFogEnabled = state
        if not state then
            Lighting.FogStart = OriginalFogStart
            Lighting.FogEnd = OriginalFogEnd
        end
    end
})


-- Global toggle
BeautifulPurpleSkyEnabled = false

Lighting = game:GetService("Lighting")

-- Store originals (globals now)
OriginalSky = Lighting:FindFirstChildOfClass("Sky")
OriginalAmbient = Lighting.Ambient
OriginalOutdoorAmbient = Lighting.OutdoorAmbient
OriginalClockTime = Lighting.ClockTime
OriginalTimeOfDay = Lighting.TimeOfDay
OriginalFogColor = Lighting.FogColor
OriginalFogStart = Lighting.FogStart
OriginalFogEnd = Lighting.FogEnd
OriginalTechnology = Lighting.Technology
OriginalShadowSoftness = Lighting.ShadowSoftness
OriginalGlobalShadows = Lighting.GlobalShadows

bloom, cc, sun, dof = nil, nil, nil, nil

Tab:Toggle({
    Title = "Beautiful Purple Sky",
    Icon = "sun",
    Type = "Toggle",
    Default = false,
    Callback = function(state)
        BeautifulPurpleSkyEnabled = state

        if state then
            
            if Lighting:FindFirstChildOfClass("Sky") then
                Lighting:FindFirstChildOfClass("Sky"):Destroy()
            end

            -- Purple Sky
            PurpleSky = Instance.new("Sky")
            PurpleSky.Name = "PurpleSky"
            PurpleSky.Parent = Lighting

            -- Advanced shadows & ambiance
            Lighting.Technology = Enum.Technology.Future
            Lighting.ShadowSoftness = 0.5
            Lighting.GlobalShadows = true
            Lighting.Ambient = Color3.fromRGB(128, 0, 128)
            Lighting.OutdoorAmbient = Color3.fromRGB(180, 0, 180)
            Lighting.ClockTime = 14
            Lighting.TimeOfDay = "14:00:00"

            -- Purple Fog
            Lighting.FogColor = Color3.fromRGB(128, 0, 128)
            Lighting.FogStart = 0
            Lighting.FogEnd = 1000

            -- Post-processing effects
            bloom = Instance.new("BloomEffect")
            bloom.Intensity = 2
            bloom.Size = 50
            bloom.Threshold = 0.5
            bloom.Parent = Lighting

            cc = Instance.new("ColorCorrectionEffect")
            cc.TintColor = Color3.fromRGB(180, 0, 180)
            cc.Contrast = 0.2
            cc.Saturation = 0.3
            cc.Parent = Lighting

            sun = Instance.new("SunRaysEffect")
            sun.Intensity = 0.3
            sun.Parent = Lighting

            dof = Instance.new("DepthOfFieldEffect")
            dof.FocusDistance = 50
            dof.InFocusRadius = 20
            dof.Parent = Lighting

        else
            -- Restore originals
            if Lighting:FindFirstChild("PurpleSky") then
                Lighting.PurpleSky:Destroy()
            end
            if bloom then bloom:Destroy() bloom = nil end
            if cc then cc:Destroy() cc = nil end
            if sun then sun:Destroy() sun = nil end
            if dof then dof:Destroy() dof = nil end

            if OriginalSky then OriginalSky.Parent = Lighting end
            Lighting.Ambient = OriginalAmbient
            Lighting.OutdoorAmbient = OriginalOutdoorAmbient
            Lighting.ClockTime = OriginalClockTime
            Lighting.TimeOfDay = OriginalTimeOfDay
            Lighting.FogColor = OriginalFogColor
            Lighting.FogStart = OriginalFogStart
            Lighting.FogEnd = OriginalFogEnd
            Lighting.Technology = OriginalTechnology
            Lighting.ShadowSoftness = OriginalShadowSoftness
            Lighting.GlobalShadows = OriginalGlobalShadows
        end
    end
})
